/* automatically generated by rust-bindgen 0.69.5 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __BITS_PER_LONG: u32 = 64;
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const KFD_IOCTL_MAJOR_VERSION: u32 = 1;
pub const KFD_IOCTL_MINOR_VERSION: u32 = 2;
pub const KFD_IOCTL_DBG_MAJOR_VERSION: u32 = 1;
pub const KFD_IOCTL_DBG_MINOR_VERSION: u32 = 0;
pub const KFD_IOC_QUEUE_TYPE_COMPUTE: u32 = 0;
pub const KFD_IOC_QUEUE_TYPE_SDMA: u32 = 1;
pub const KFD_IOC_QUEUE_TYPE_COMPUTE_AQL: u32 = 2;
pub const KFD_IOC_QUEUE_TYPE_SDMA_XGMI: u32 = 3;
pub const KFD_MAX_QUEUE_PERCENTAGE: u32 = 100;
pub const KFD_MAX_QUEUE_PRIORITY: u32 = 15;
pub const KFD_IOC_CACHE_POLICY_COHERENT: u32 = 0;
pub const KFD_IOC_CACHE_POLICY_NONCOHERENT: u32 = 1;
pub const NUM_OF_SUPPORTED_GPUS: u32 = 7;
pub const MAX_ALLOWED_NUM_POINTS: u32 = 100;
pub const MAX_ALLOWED_AW_BUFF_SIZE: u32 = 4096;
pub const MAX_ALLOWED_WAC_BUFF_SIZE: u32 = 128;
pub const KFD_DBG_EV_STATUS_TRAP: u32 = 1;
pub const KFD_DBG_EV_STATUS_VMFAULT: u32 = 2;
pub const KFD_DBG_EV_STATUS_SUSPENDED: u32 = 4;
pub const KFD_DBG_EV_STATUS_NEW_QUEUE: u32 = 8;
pub const KFD_DBG_EV_FLAG_CLEAR_STATUS: u32 = 1;
pub const KFD_INVALID_QUEUEID: u32 = 4294967295;
pub const KFD_IOC_DBG_TRAP_ENABLE: u32 = 0;
pub const KFD_IOC_DBG_TRAP_SET_WAVE_LAUNCH_OVERRIDE: u32 = 1;
pub const KFD_IOC_DBG_TRAP_SET_WAVE_LAUNCH_MODE: u32 = 2;
pub const KFD_IOC_DBG_TRAP_NODE_SUSPEND: u32 = 3;
pub const KFD_IOC_DBG_TRAP_NODE_RESUME: u32 = 4;
pub const KFD_IOC_DBG_TRAP_QUERY_DEBUG_EVENT: u32 = 5;
pub const KFD_IOC_DBG_TRAP_GET_QUEUE_SNAPSHOT: u32 = 6;
pub const KFD_IOC_DBG_TRAP_GET_VERSION: u32 = 7;
pub const KFD_IOC_EVENT_SIGNAL: u32 = 0;
pub const KFD_IOC_EVENT_NODECHANGE: u32 = 1;
pub const KFD_IOC_EVENT_DEVICESTATECHANGE: u32 = 2;
pub const KFD_IOC_EVENT_HW_EXCEPTION: u32 = 3;
pub const KFD_IOC_EVENT_SYSTEM_EVENT: u32 = 4;
pub const KFD_IOC_EVENT_DEBUG_EVENT: u32 = 5;
pub const KFD_IOC_EVENT_PROFILE_EVENT: u32 = 6;
pub const KFD_IOC_EVENT_QUEUE_EVENT: u32 = 7;
pub const KFD_IOC_EVENT_MEMORY: u32 = 8;
pub const KFD_IOC_WAIT_RESULT_COMPLETE: u32 = 0;
pub const KFD_IOC_WAIT_RESULT_TIMEOUT: u32 = 1;
pub const KFD_IOC_WAIT_RESULT_FAIL: u32 = 2;
pub const KFD_SIGNAL_EVENT_LIMIT: u32 = 4096;
pub const KFD_HW_EXCEPTION_WHOLE_GPU_RESET: u32 = 0;
pub const KFD_HW_EXCEPTION_PER_ENGINE_RESET: u32 = 1;
pub const KFD_HW_EXCEPTION_GPU_HANG: u32 = 0;
pub const KFD_HW_EXCEPTION_ECC: u32 = 1;
pub const KFD_MEM_ERR_NO_RAS: u32 = 0;
pub const KFD_MEM_ERR_SRAM_ECC: u32 = 1;
pub const KFD_MEM_ERR_POISON_CONSUMED: u32 = 2;
pub const KFD_MEM_ERR_GPU_HANG: u32 = 3;
pub const KFD_IOC_ALLOC_MEM_FLAGS_VRAM: u32 = 1;
pub const KFD_IOC_ALLOC_MEM_FLAGS_GTT: u32 = 2;
pub const KFD_IOC_ALLOC_MEM_FLAGS_USERPTR: u32 = 4;
pub const KFD_IOC_ALLOC_MEM_FLAGS_DOORBELL: u32 = 8;
pub const KFD_IOC_ALLOC_MEM_FLAGS_MMIO_REMAP: u32 = 16;
pub const KFD_IOC_ALLOC_MEM_FLAGS_WRITABLE: u32 = 2147483648;
pub const KFD_IOC_ALLOC_MEM_FLAGS_EXECUTABLE: u32 = 1073741824;
pub const KFD_IOC_ALLOC_MEM_FLAGS_PUBLIC: u32 = 536870912;
pub const KFD_IOC_ALLOC_MEM_FLAGS_NO_SUBSTITUTE: u32 = 268435456;
pub const KFD_IOC_ALLOC_MEM_FLAGS_AQL_QUEUE_MEM: u32 = 134217728;
pub const KFD_IOC_ALLOC_MEM_FLAGS_COHERENT: u32 = 67108864;
pub const KFD_CROSS_MEMORY_RW_BIT: u32 = 1;
pub const AMDKFD_IOCTL_BASE: u8 = 75u8;
pub const AMDKFD_COMMAND_START: u32 = 1;
pub const AMDKFD_COMMAND_END: u32 = 32;
pub const RSMI_MAX_NUM_FREQUENCIES: u32 = 33;
pub const RSMI_MAX_FAN_SPEED: u32 = 255;
pub const RSMI_NUM_VOLTAGE_CURVE_POINTS: u32 = 3;
pub const MAX_EVENT_NOTIFICATION_MSG_SIZE: u32 = 64;
pub const CPU_NODE_INDEX: u32 = 4294967295;
pub const CENTRIGRADE_TO_MILLI_CENTIGRADE: u32 = 1000;
pub const RSMI_NUM_HBM_INSTANCES: u32 = 4;
pub const RSMI_MAX_NUM_VCNS: u32 = 4;
pub const RSMI_MAX_NUM_JPEG_ENGS: u32 = 32;
pub const RSMI_MAX_NUM_CLKS: u32 = 4;
pub const RSMI_MAX_NUM_XGMI_LINKS: u32 = 8;
pub const RSMI_MAX_NUM_GFX_CLKS: u32 = 8;
pub const RSMI_DEFAULT_VARIANT: i32 = -1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_version_args {
    pub major_version: __u32,
    pub minor_version: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_version_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_version_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_version_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_get_version_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_version_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_get_version_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_version_args),
            "::",
            stringify!(major_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_version_args),
            "::",
            stringify!(minor_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_available_memory_args {
    pub available: __u64,
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_available_memory_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_available_memory_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_available_memory_args>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_ioctl_get_available_memory_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_available_memory_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_get_available_memory_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_available_memory_args),
            "::",
            stringify!(available)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_available_memory_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_available_memory_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_create_queue_args {
    pub ring_base_address: __u64,
    pub write_pointer_address: __u64,
    pub read_pointer_address: __u64,
    pub doorbell_offset: __u64,
    pub ring_size: __u32,
    pub gpu_id: __u32,
    pub queue_type: __u32,
    pub queue_percentage: __u32,
    pub queue_priority: __u32,
    pub queue_id: __u32,
    pub eop_buffer_address: __u64,
    pub eop_buffer_size: __u64,
    pub ctx_save_restore_address: __u64,
    pub ctx_save_restore_size: __u32,
    pub ctl_stack_size: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_create_queue_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_create_queue_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_create_queue_args>(),
        88usize,
        concat!("Size of: ", stringify!(kfd_ioctl_create_queue_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_create_queue_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_create_queue_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_base_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(ring_base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_pointer_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(write_pointer_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_pointer_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(read_pointer_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doorbell_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(doorbell_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(queue_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_percentage) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(queue_percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_priority) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(queue_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eop_buffer_address) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(eop_buffer_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eop_buffer_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(eop_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_save_restore_address) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(ctx_save_restore_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_save_restore_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(ctx_save_restore_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctl_stack_size) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_queue_args),
            "::",
            stringify!(ctl_stack_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_destroy_queue_args {
    pub queue_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_destroy_queue_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_destroy_queue_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_destroy_queue_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_destroy_queue_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_destroy_queue_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_destroy_queue_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_destroy_queue_args),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_destroy_queue_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_update_queue_args {
    pub ring_base_address: __u64,
    pub queue_id: __u32,
    pub ring_size: __u32,
    pub queue_percentage: __u32,
    pub queue_priority: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_update_queue_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_update_queue_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_update_queue_args>(),
        24usize,
        concat!("Size of: ", stringify!(kfd_ioctl_update_queue_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_update_queue_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_update_queue_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_base_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_update_queue_args),
            "::",
            stringify!(ring_base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_update_queue_args),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_update_queue_args),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_percentage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_update_queue_args),
            "::",
            stringify!(queue_percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_update_queue_args),
            "::",
            stringify!(queue_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_set_cu_mask_args {
    pub queue_id: __u32,
    pub num_cu_mask: __u32,
    pub cu_mask_ptr: __u64,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_set_cu_mask_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_set_cu_mask_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_set_cu_mask_args>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_ioctl_set_cu_mask_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_set_cu_mask_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_set_cu_mask_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_cu_mask_args),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cu_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_cu_mask_args),
            "::",
            stringify!(num_cu_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_mask_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_cu_mask_args),
            "::",
            stringify!(cu_mask_ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_queue_wave_state_args {
    pub ctl_stack_address: __u64,
    pub ctl_stack_used_size: __u32,
    pub save_area_used_size: __u32,
    pub queue_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_queue_wave_state_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_queue_wave_state_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_queue_wave_state_args>(),
        24usize,
        concat!("Size of: ", stringify!(kfd_ioctl_get_queue_wave_state_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_queue_wave_state_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_get_queue_wave_state_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctl_stack_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_queue_wave_state_args),
            "::",
            stringify!(ctl_stack_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctl_stack_used_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_queue_wave_state_args),
            "::",
            stringify!(ctl_stack_used_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_area_used_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_queue_wave_state_args),
            "::",
            stringify!(save_area_used_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_queue_wave_state_args),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_queue_wave_state_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_queue_snapshot_entry {
    pub ring_base_address: __u64,
    pub write_pointer_address: __u64,
    pub read_pointer_address: __u64,
    pub ctx_save_restore_address: __u64,
    pub queue_id: __u32,
    pub gpu_id: __u32,
    pub ring_size: __u32,
    pub queue_type: __u32,
    pub queue_status: __u32,
    pub reserved: [__u32; 19usize],
}
#[test]
fn bindgen_test_layout_kfd_queue_snapshot_entry() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_queue_snapshot_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_queue_snapshot_entry>(),
        128usize,
        concat!("Size of: ", stringify!(kfd_queue_snapshot_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_queue_snapshot_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_queue_snapshot_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_base_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(ring_base_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_pointer_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(write_pointer_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_pointer_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(read_pointer_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_save_restore_address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(ctx_save_restore_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_type) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(queue_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(queue_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_queue_snapshot_entry),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_set_memory_policy_args {
    pub alternate_aperture_base: __u64,
    pub alternate_aperture_size: __u64,
    pub gpu_id: __u32,
    pub default_policy: __u32,
    pub alternate_policy: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_set_memory_policy_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_set_memory_policy_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_set_memory_policy_args>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_ioctl_set_memory_policy_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_set_memory_policy_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_set_memory_policy_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alternate_aperture_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_memory_policy_args),
            "::",
            stringify!(alternate_aperture_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alternate_aperture_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_memory_policy_args),
            "::",
            stringify!(alternate_aperture_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_memory_policy_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_policy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_memory_policy_args),
            "::",
            stringify!(default_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alternate_policy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_memory_policy_args),
            "::",
            stringify!(alternate_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_memory_policy_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_clock_counters_args {
    pub gpu_clock_counter: __u64,
    pub cpu_clock_counter: __u64,
    pub system_clock_counter: __u64,
    pub system_clock_freq: __u64,
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_clock_counters_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_clock_counters_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_clock_counters_args>(),
        40usize,
        concat!("Size of: ", stringify!(kfd_ioctl_get_clock_counters_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_clock_counters_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_get_clock_counters_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_clock_counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_clock_counters_args),
            "::",
            stringify!(gpu_clock_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_clock_counter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_clock_counters_args),
            "::",
            stringify!(cpu_clock_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_clock_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_clock_counters_args),
            "::",
            stringify!(system_clock_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_clock_freq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_clock_counters_args),
            "::",
            stringify!(system_clock_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_clock_counters_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_clock_counters_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_process_device_apertures {
    pub lds_base: __u64,
    pub lds_limit: __u64,
    pub scratch_base: __u64,
    pub scratch_limit: __u64,
    pub gpuvm_base: __u64,
    pub gpuvm_limit: __u64,
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_process_device_apertures() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_process_device_apertures> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_process_device_apertures>(),
        56usize,
        concat!("Size of: ", stringify!(kfd_process_device_apertures))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_process_device_apertures>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_process_device_apertures))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lds_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(lds_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lds_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(lds_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scratch_base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(scratch_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scratch_limit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(scratch_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuvm_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(gpuvm_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuvm_limit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(gpuvm_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_process_device_apertures),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_process_apertures_args {
    pub process_apertures: [kfd_process_device_apertures; 7usize],
    pub num_of_nodes: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_process_apertures_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_process_apertures_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_process_apertures_args>(),
        400usize,
        concat!(
            "Size of: ",
            stringify!(kfd_ioctl_get_process_apertures_args)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_process_apertures_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_get_process_apertures_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_apertures) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_process_apertures_args),
            "::",
            stringify!(process_apertures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_of_nodes) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_process_apertures_args),
            "::",
            stringify!(num_of_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_process_apertures_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_process_apertures_new_args {
    pub kfd_process_device_apertures_ptr: __u64,
    pub num_of_nodes: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_process_apertures_new_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_process_apertures_new_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_process_apertures_new_args>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(kfd_ioctl_get_process_apertures_new_args)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_process_apertures_new_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_get_process_apertures_new_args)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).kfd_process_device_apertures_ptr) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_process_apertures_new_args),
            "::",
            stringify!(kfd_process_device_apertures_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_of_nodes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_process_apertures_new_args),
            "::",
            stringify!(num_of_nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_process_apertures_new_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_dbg_register_args {
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_dbg_register_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_dbg_register_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_dbg_register_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_dbg_register_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_dbg_register_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_dbg_register_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_register_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_register_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_dbg_unregister_args {
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_dbg_unregister_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_dbg_unregister_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_dbg_unregister_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_dbg_unregister_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_dbg_unregister_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_dbg_unregister_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_unregister_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_unregister_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_dbg_address_watch_args {
    pub content_ptr: __u64,
    pub gpu_id: __u32,
    pub buf_size_in_bytes: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_dbg_address_watch_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_dbg_address_watch_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_dbg_address_watch_args>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_ioctl_dbg_address_watch_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_dbg_address_watch_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_dbg_address_watch_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_address_watch_args),
            "::",
            stringify!(content_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_address_watch_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size_in_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_address_watch_args),
            "::",
            stringify!(buf_size_in_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_dbg_wave_control_args {
    pub content_ptr: __u64,
    pub gpu_id: __u32,
    pub buf_size_in_bytes: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_dbg_wave_control_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_dbg_wave_control_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_dbg_wave_control_args>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_ioctl_dbg_wave_control_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_dbg_wave_control_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_dbg_wave_control_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_wave_control_args),
            "::",
            stringify!(content_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_wave_control_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size_in_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_wave_control_args),
            "::",
            stringify!(buf_size_in_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_dbg_trap_args {
    pub ptr: __u64,
    pub pid: __u32,
    pub gpu_id: __u32,
    pub op: __u32,
    pub data1: __u32,
    pub data2: __u32,
    pub data3: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_dbg_trap_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_dbg_trap_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_dbg_trap_args>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_ioctl_dbg_trap_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_dbg_trap_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_dbg_trap_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data3) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_dbg_trap_args),
            "::",
            stringify!(data3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_create_event_args {
    pub event_page_offset: __u64,
    pub event_trigger_data: __u32,
    pub event_type: __u32,
    pub auto_reset: __u32,
    pub node_id: __u32,
    pub event_id: __u32,
    pub event_slot_index: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_create_event_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_create_event_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_create_event_args>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_ioctl_create_event_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_create_event_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_create_event_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_page_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(event_page_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_trigger_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(event_trigger_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auto_reset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(auto_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_slot_index) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_create_event_args),
            "::",
            stringify!(event_slot_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_destroy_event_args {
    pub event_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_destroy_event_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_destroy_event_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_destroy_event_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_destroy_event_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_destroy_event_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_destroy_event_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_destroy_event_args),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_destroy_event_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_set_event_args {
    pub event_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_set_event_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_set_event_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_set_event_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_set_event_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_set_event_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_set_event_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_event_args),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_event_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_reset_event_args {
    pub event_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_reset_event_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_reset_event_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_reset_event_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_reset_event_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_reset_event_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_reset_event_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_reset_event_args),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_reset_event_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_memory_exception_failure {
    pub NotPresent: __u32,
    pub ReadOnly: __u32,
    pub NoExecute: __u32,
    pub imprecise: __u32,
}
#[test]
fn bindgen_test_layout_kfd_memory_exception_failure() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_memory_exception_failure> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_memory_exception_failure>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_memory_exception_failure))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_memory_exception_failure>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_memory_exception_failure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NotPresent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_memory_exception_failure),
            "::",
            stringify!(NotPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOnly) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_memory_exception_failure),
            "::",
            stringify!(ReadOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NoExecute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_memory_exception_failure),
            "::",
            stringify!(NoExecute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imprecise) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_memory_exception_failure),
            "::",
            stringify!(imprecise)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_hsa_memory_exception_data {
    pub failure: kfd_memory_exception_failure,
    pub va: __u64,
    pub gpu_id: __u32,
    pub ErrorType: __u32,
}
#[test]
fn bindgen_test_layout_kfd_hsa_memory_exception_data() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_hsa_memory_exception_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_hsa_memory_exception_data>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_hsa_memory_exception_data))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_hsa_memory_exception_data>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_hsa_memory_exception_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_memory_exception_data),
            "::",
            stringify!(failure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_memory_exception_data),
            "::",
            stringify!(va)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_memory_exception_data),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_memory_exception_data),
            "::",
            stringify!(ErrorType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_hsa_hw_exception_data {
    pub reset_type: __u32,
    pub reset_cause: __u32,
    pub memory_lost: __u32,
    pub gpu_id: __u32,
}
#[test]
fn bindgen_test_layout_kfd_hsa_hw_exception_data() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_hsa_hw_exception_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_hsa_hw_exception_data>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_hsa_hw_exception_data))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_hsa_hw_exception_data>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_hsa_hw_exception_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_hw_exception_data),
            "::",
            stringify!(reset_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset_cause) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_hw_exception_data),
            "::",
            stringify!(reset_cause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_lost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_hw_exception_data),
            "::",
            stringify!(memory_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_hsa_hw_exception_data),
            "::",
            stringify!(gpu_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kfd_event_data {
    pub __bindgen_anon_1: kfd_event_data__bindgen_ty_1,
    pub kfd_event_data_ext: __u64,
    pub event_id: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kfd_event_data__bindgen_ty_1 {
    pub memory_exception_data: kfd_hsa_memory_exception_data,
    pub hw_exception_data: kfd_hsa_hw_exception_data,
}
#[test]
fn bindgen_test_layout_kfd_event_data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_event_data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_event_data__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_event_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_event_data__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_event_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_exception_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_event_data__bindgen_ty_1),
            "::",
            stringify!(memory_exception_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hw_exception_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_event_data__bindgen_ty_1),
            "::",
            stringify!(hw_exception_data)
        )
    );
}
#[test]
fn bindgen_test_layout_kfd_event_data() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_event_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_event_data>(),
        48usize,
        concat!("Size of: ", stringify!(kfd_event_data))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_event_data>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_event_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kfd_event_data_ext) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_event_data),
            "::",
            stringify!(kfd_event_data_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_event_data),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_event_data),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_wait_events_args {
    pub events_ptr: __u64,
    pub num_events: __u32,
    pub wait_for_all: __u32,
    pub timeout: __u32,
    pub wait_result: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_wait_events_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_wait_events_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_wait_events_args>(),
        24usize,
        concat!("Size of: ", stringify!(kfd_ioctl_wait_events_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_wait_events_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_wait_events_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_wait_events_args),
            "::",
            stringify!(events_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_events) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_wait_events_args),
            "::",
            stringify!(num_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait_for_all) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_wait_events_args),
            "::",
            stringify!(wait_for_all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_wait_events_args),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait_result) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_wait_events_args),
            "::",
            stringify!(wait_result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_set_scratch_backing_va_args {
    pub va_addr: __u64,
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_set_scratch_backing_va_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_set_scratch_backing_va_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_set_scratch_backing_va_args>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(kfd_ioctl_set_scratch_backing_va_args)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_set_scratch_backing_va_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_set_scratch_backing_va_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_scratch_backing_va_args),
            "::",
            stringify!(va_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_scratch_backing_va_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_scratch_backing_va_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_tile_config_args {
    pub tile_config_ptr: __u64,
    pub macro_tile_config_ptr: __u64,
    pub num_tile_configs: __u32,
    pub num_macro_tile_configs: __u32,
    pub gpu_id: __u32,
    pub gb_addr_config: __u32,
    pub num_banks: __u32,
    pub num_ranks: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_tile_config_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_tile_config_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_tile_config_args>(),
        40usize,
        concat!("Size of: ", stringify!(kfd_ioctl_get_tile_config_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_tile_config_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_get_tile_config_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_config_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(tile_config_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macro_tile_config_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(macro_tile_config_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_tile_configs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(num_tile_configs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_macro_tile_configs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(num_macro_tile_configs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gb_addr_config) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(gb_addr_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_banks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(num_banks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_ranks) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_tile_config_args),
            "::",
            stringify!(num_ranks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_set_trap_handler_args {
    pub tba_addr: __u64,
    pub tma_addr: __u64,
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_set_trap_handler_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_set_trap_handler_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_set_trap_handler_args>(),
        24usize,
        concat!("Size of: ", stringify!(kfd_ioctl_set_trap_handler_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_set_trap_handler_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_set_trap_handler_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tba_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_trap_handler_args),
            "::",
            stringify!(tba_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tma_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_trap_handler_args),
            "::",
            stringify!(tma_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_trap_handler_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_set_trap_handler_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_acquire_vm_args {
    pub drm_fd: __u32,
    pub gpu_id: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_acquire_vm_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_acquire_vm_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_acquire_vm_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_acquire_vm_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_acquire_vm_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_acquire_vm_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drm_fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_acquire_vm_args),
            "::",
            stringify!(drm_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_acquire_vm_args),
            "::",
            stringify!(gpu_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_alloc_memory_of_gpu_args {
    pub va_addr: __u64,
    pub size: __u64,
    pub handle: __u64,
    pub mmap_offset: __u64,
    pub gpu_id: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_alloc_memory_of_gpu_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_alloc_memory_of_gpu_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_alloc_memory_of_gpu_args>(),
        40usize,
        concat!("Size of: ", stringify!(kfd_ioctl_alloc_memory_of_gpu_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_alloc_memory_of_gpu_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args),
            "::",
            stringify!(va_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args),
            "::",
            stringify!(mmap_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_memory_of_gpu_args),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_free_memory_of_gpu_args {
    pub handle: __u64,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_free_memory_of_gpu_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_free_memory_of_gpu_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_free_memory_of_gpu_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_free_memory_of_gpu_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_free_memory_of_gpu_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_free_memory_of_gpu_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_free_memory_of_gpu_args),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_map_memory_to_gpu_args {
    pub handle: __u64,
    pub device_ids_array_ptr: __u64,
    pub n_devices: __u32,
    pub n_success: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_map_memory_to_gpu_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_map_memory_to_gpu_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_map_memory_to_gpu_args>(),
        24usize,
        concat!("Size of: ", stringify!(kfd_ioctl_map_memory_to_gpu_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_map_memory_to_gpu_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_map_memory_to_gpu_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_map_memory_to_gpu_args),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_ids_array_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_map_memory_to_gpu_args),
            "::",
            stringify!(device_ids_array_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_devices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_map_memory_to_gpu_args),
            "::",
            stringify!(n_devices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_success) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_map_memory_to_gpu_args),
            "::",
            stringify!(n_success)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_unmap_memory_from_gpu_args {
    pub handle: __u64,
    pub device_ids_array_ptr: __u64,
    pub n_devices: __u32,
    pub n_success: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_unmap_memory_from_gpu_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_unmap_memory_from_gpu_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_unmap_memory_from_gpu_args>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(kfd_ioctl_unmap_memory_from_gpu_args)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_unmap_memory_from_gpu_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_unmap_memory_from_gpu_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_unmap_memory_from_gpu_args),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_ids_array_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_unmap_memory_from_gpu_args),
            "::",
            stringify!(device_ids_array_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_devices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_unmap_memory_from_gpu_args),
            "::",
            stringify!(n_devices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_success) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_unmap_memory_from_gpu_args),
            "::",
            stringify!(n_success)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_alloc_queue_gws_args {
    pub queue_id: __u32,
    pub num_gws: __u32,
    pub first_gws: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_alloc_queue_gws_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_alloc_queue_gws_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_alloc_queue_gws_args>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_ioctl_alloc_queue_gws_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_alloc_queue_gws_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_alloc_queue_gws_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_queue_gws_args),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_gws) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_queue_gws_args),
            "::",
            stringify!(num_gws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_gws) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_queue_gws_args),
            "::",
            stringify!(first_gws)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_alloc_queue_gws_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_get_dmabuf_info_args {
    pub size: __u64,
    pub metadata_ptr: __u64,
    pub metadata_size: __u32,
    pub gpu_id: __u32,
    pub flags: __u32,
    pub dmabuf_fd: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_get_dmabuf_info_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_get_dmabuf_info_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_get_dmabuf_info_args>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_ioctl_get_dmabuf_info_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_get_dmabuf_info_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_get_dmabuf_info_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_dmabuf_info_args),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_dmabuf_info_args),
            "::",
            stringify!(metadata_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_dmabuf_info_args),
            "::",
            stringify!(metadata_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_dmabuf_info_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_dmabuf_info_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmabuf_fd) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_get_dmabuf_info_args),
            "::",
            stringify!(dmabuf_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_import_dmabuf_args {
    pub va_addr: __u64,
    pub handle: __u64,
    pub gpu_id: __u32,
    pub dmabuf_fd: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_import_dmabuf_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_import_dmabuf_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_import_dmabuf_args>(),
        24usize,
        concat!("Size of: ", stringify!(kfd_ioctl_import_dmabuf_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_import_dmabuf_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_import_dmabuf_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_import_dmabuf_args),
            "::",
            stringify!(va_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_import_dmabuf_args),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_import_dmabuf_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmabuf_fd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_import_dmabuf_args),
            "::",
            stringify!(dmabuf_fd)
        )
    );
}
pub const kfd_smi_event_KFD_SMI_EVENT_NONE: kfd_smi_event = 0;
pub const kfd_smi_event_KFD_SMI_EVENT_VMFAULT: kfd_smi_event = 1;
pub const kfd_smi_event_KFD_SMI_EVENT_THERMAL_THROTTLE: kfd_smi_event = 2;
pub const kfd_smi_event_KFD_SMI_EVENT_GPU_PRE_RESET: kfd_smi_event = 3;
pub const kfd_smi_event_KFD_SMI_EVENT_GPU_POST_RESET: kfd_smi_event = 4;
pub const kfd_smi_event_KFD_SMI_EVENT_RING_HANG: kfd_smi_event = 5;
pub type kfd_smi_event = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_smi_events_args {
    pub gpuid: __u32,
    pub anon_fd: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_smi_events_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_smi_events_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_smi_events_args>(),
        8usize,
        concat!("Size of: ", stringify!(kfd_ioctl_smi_events_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_smi_events_args>(),
        4usize,
        concat!("Alignment of ", stringify!(kfd_ioctl_smi_events_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_smi_events_args),
            "::",
            stringify!(gpuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anon_fd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_smi_events_args),
            "::",
            stringify!(anon_fd)
        )
    );
}
pub const kfd_mmio_remap_KFD_MMIO_REMAP_HDP_MEM_FLUSH_CNTL: kfd_mmio_remap = 0;
pub const kfd_mmio_remap_KFD_MMIO_REMAP_HDP_REG_FLUSH_CNTL: kfd_mmio_remap = 4;
pub type kfd_mmio_remap = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_ipc_export_handle_args {
    pub handle: __u64,
    pub share_handle: [__u32; 4usize],
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_ipc_export_handle_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_ipc_export_handle_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_ipc_export_handle_args>(),
        32usize,
        concat!("Size of: ", stringify!(kfd_ioctl_ipc_export_handle_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_ipc_export_handle_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_ipc_export_handle_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_export_handle_args),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).share_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_export_handle_args),
            "::",
            stringify!(share_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_export_handle_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_export_handle_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_ipc_import_handle_args {
    pub handle: __u64,
    pub va_addr: __u64,
    pub mmap_offset: __u64,
    pub share_handle: [__u32; 4usize],
    pub gpu_id: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_ipc_import_handle_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_ipc_import_handle_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_ipc_import_handle_args>(),
        48usize,
        concat!("Size of: ", stringify!(kfd_ioctl_ipc_import_handle_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_ipc_import_handle_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_ipc_import_handle_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_import_handle_args),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_import_handle_args),
            "::",
            stringify!(va_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmap_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_import_handle_args),
            "::",
            stringify!(mmap_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).share_handle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_import_handle_args),
            "::",
            stringify!(share_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_import_handle_args),
            "::",
            stringify!(gpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_ipc_import_handle_args),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_memory_range {
    pub va_addr: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_kfd_memory_range() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_memory_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_memory_range>(),
        16usize,
        concat!("Size of: ", stringify!(kfd_memory_range))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_memory_range>(),
        8usize,
        concat!("Alignment of ", stringify!(kfd_memory_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_memory_range),
            "::",
            stringify!(va_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_memory_range),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kfd_ioctl_cross_memory_copy_args {
    pub pid: __u32,
    pub flags: __u32,
    pub src_mem_range_array: __u64,
    pub src_mem_array_size: __u64,
    pub dst_mem_range_array: __u64,
    pub dst_mem_array_size: __u64,
    pub bytes_copied: __u64,
}
#[test]
fn bindgen_test_layout_kfd_ioctl_cross_memory_copy_args() {
    const UNINIT: ::std::mem::MaybeUninit<kfd_ioctl_cross_memory_copy_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kfd_ioctl_cross_memory_copy_args>(),
        48usize,
        concat!("Size of: ", stringify!(kfd_ioctl_cross_memory_copy_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kfd_ioctl_cross_memory_copy_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(kfd_ioctl_cross_memory_copy_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_mem_range_array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(src_mem_range_array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_mem_array_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(src_mem_array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_mem_range_array) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(dst_mem_range_array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_mem_array_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(dst_mem_array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_copied) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kfd_ioctl_cross_memory_copy_args),
            "::",
            stringify!(bytes_copied)
        )
    );
}
#[doc = "!< Operation was successful"]
pub const rsmi_status_t_RSMI_STATUS_SUCCESS: rsmi_status_t = 0;
#[doc = "!< Passed in arguments are not valid"]
pub const rsmi_status_t_RSMI_STATUS_INVALID_ARGS: rsmi_status_t = 1;
#[doc = "!< The requested information or\n!< action is not available for the\n!< given input, on the given system"]
pub const rsmi_status_t_RSMI_STATUS_NOT_SUPPORTED: rsmi_status_t = 2;
#[doc = "!< Problem accessing a file. This\n!< may because the operation is not\n!< supported by the Linux kernel\n!< version running on the executing\n!< machine"]
pub const rsmi_status_t_RSMI_STATUS_FILE_ERROR: rsmi_status_t = 3;
#[doc = "!< Permission denied/EACCESS file\n!< error. Many functions require\n!< root access to run."]
pub const rsmi_status_t_RSMI_STATUS_PERMISSION: rsmi_status_t = 4;
#[doc = "!< Unable to acquire memory or other\n!< resource"]
pub const rsmi_status_t_RSMI_STATUS_OUT_OF_RESOURCES: rsmi_status_t = 5;
#[doc = "!< An internal exception was caught"]
pub const rsmi_status_t_RSMI_STATUS_INTERNAL_EXCEPTION: rsmi_status_t = 6;
#[doc = "!< The provided input is out of\n!< allowable or safe range"]
pub const rsmi_status_t_RSMI_STATUS_INPUT_OUT_OF_BOUNDS: rsmi_status_t = 7;
#[doc = "!< An error occurred when rsmi\n!< initializing internal data\n!< structures"]
pub const rsmi_status_t_RSMI_STATUS_INIT_ERROR: rsmi_status_t = 8;
pub const rsmi_status_t_RSMI_INITIALIZATION_ERROR: rsmi_status_t = 8;
#[doc = "!< The requested function has not\n!< yet been implemented in the\n!< current system for the current\n!< devices"]
pub const rsmi_status_t_RSMI_STATUS_NOT_YET_IMPLEMENTED: rsmi_status_t = 9;
#[doc = "!< An item was searched for but not\n!< found"]
pub const rsmi_status_t_RSMI_STATUS_NOT_FOUND: rsmi_status_t = 10;
#[doc = "!< Not enough resources were\n!< available for the operation"]
pub const rsmi_status_t_RSMI_STATUS_INSUFFICIENT_SIZE: rsmi_status_t = 11;
#[doc = "!< An interrupt occurred during\n!< execution of function"]
pub const rsmi_status_t_RSMI_STATUS_INTERRUPT: rsmi_status_t = 12;
#[doc = "!< An unexpected amount of data\n!< was read"]
pub const rsmi_status_t_RSMI_STATUS_UNEXPECTED_SIZE: rsmi_status_t = 13;
#[doc = "!< No data was found for a given\n!< input"]
pub const rsmi_status_t_RSMI_STATUS_NO_DATA: rsmi_status_t = 14;
#[doc = "!< The data read or provided to\n!< function is not what was expected"]
pub const rsmi_status_t_RSMI_STATUS_UNEXPECTED_DATA: rsmi_status_t = 15;
#[doc = "!< A resource or mutex could not be\n!< acquired because it is already\n!< being used"]
pub const rsmi_status_t_RSMI_STATUS_BUSY: rsmi_status_t = 16;
#[doc = "!< An internal reference counter\n!< exceeded INT32_MAX"]
pub const rsmi_status_t_RSMI_STATUS_REFCOUNT_OVERFLOW: rsmi_status_t = 17;
#[doc = "!< Requested setting is unavailable\n!< for the current device"]
pub const rsmi_status_t_RSMI_STATUS_SETTING_UNAVAILABLE: rsmi_status_t = 18;
#[doc = "!< Could not successfully restart\n!< the amdgpu driver"]
pub const rsmi_status_t_RSMI_STATUS_AMDGPU_RESTART_ERR: rsmi_status_t = 19;
#[doc = "!< An unknown error occurred"]
pub const rsmi_status_t_RSMI_STATUS_UNKNOWN_ERROR: rsmi_status_t = 4294967295;
#[doc = " @brief Error codes retured by rocm_smi_lib functions"]
pub type rsmi_status_t = ::std::os::raw::c_uint;
#[doc = "!< Attempt to add all GPUs found\n!< (including non-AMD) to the list\n!< of devices from which SMI\n!< information can be retrieved. By\n!< default, only AMD devices are\n!<  enumerated by RSMI."]
pub const rsmi_init_flags_t_RSMI_INIT_FLAG_ALL_GPUS: rsmi_init_flags_t = 1;
#[doc = "!< Reserved for test"]
pub const rsmi_init_flags_t_RSMI_INIT_FLAG_RESRV_TEST1: rsmi_init_flags_t = 576460752303423488;
#[doc = " @brief Initialization flags\n\n Initialization flags may be OR'd together and passed to ::rsmi_init()."]
pub type rsmi_init_flags_t = ::std::os::raw::c_ulong;
#[doc = "!< Performance level is \"auto\""]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_AUTO: rsmi_dev_perf_level_t = 0;
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_FIRST: rsmi_dev_perf_level_t = 0;
#[doc = "!< Keep PowerPlay levels \"low\",\n!< regardless of workload"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_LOW: rsmi_dev_perf_level_t = 1;
#[doc = "!< Keep PowerPlay levels \"high\",\n!< regardless of workload"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_HIGH: rsmi_dev_perf_level_t = 2;
#[doc = "!< Only use values defined by manually\n!< setting the RSMI_CLK_TYPE_SYS speed"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_MANUAL: rsmi_dev_perf_level_t = 3;
#[doc = "!< Stable power state with profiling\n!< clocks"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_STABLE_STD: rsmi_dev_perf_level_t = 4;
#[doc = "!< Stable power state with peak clocks"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_STABLE_PEAK: rsmi_dev_perf_level_t = 5;
#[doc = "!< Stable power state with minimum\n!< memory clock"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_STABLE_MIN_MCLK: rsmi_dev_perf_level_t = 6;
#[doc = "!< Stable power state with minimum\n!< system clock"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_STABLE_MIN_SCLK: rsmi_dev_perf_level_t = 7;
#[doc = "!< Performance determinism state"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_DETERMINISM: rsmi_dev_perf_level_t = 8;
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_LAST: rsmi_dev_perf_level_t = 8;
#[doc = "!< Unknown performance level"]
pub const rsmi_dev_perf_level_t_RSMI_DEV_PERF_LEVEL_UNKNOWN: rsmi_dev_perf_level_t = 256;
#[doc = " @brief PowerPlay performance levels"]
pub type rsmi_dev_perf_level_t = ::std::os::raw::c_uint;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_dev_perf_level_t as rsmi_dev_perf_level;
pub const rsmi_sw_component_t_RSMI_SW_COMP_FIRST: rsmi_sw_component_t = 0;
#[doc = "!< Driver"]
pub const rsmi_sw_component_t_RSMI_SW_COMP_DRIVER: rsmi_sw_component_t = 0;
pub const rsmi_sw_component_t_RSMI_SW_COMP_LAST: rsmi_sw_component_t = 0;
#[doc = " @brief Software components"]
pub type rsmi_sw_component_t = ::std::os::raw::c_uint;
#[doc = " @brief Handle to performance event counter"]
pub type rsmi_event_handle_t = usize;
#[doc = "!< Data Fabric (XGMI) related events"]
pub const rsmi_event_group_t_RSMI_EVNT_GRP_XGMI: rsmi_event_group_t = 0;
#[doc = "!< XGMI Outbound data"]
pub const rsmi_event_group_t_RSMI_EVNT_GRP_XGMI_DATA_OUT: rsmi_event_group_t = 10;
pub const rsmi_event_group_t_RSMI_EVNT_GRP_INVALID: rsmi_event_group_t = 4294967295;
#[doc = " Event Groups\n\n @brief Enum denoting an event group. The value of the enum is the\n base value for all the event enums in the group."]
pub type rsmi_event_group_t = ::std::os::raw::c_uint;
pub const rsmi_event_type_t_RSMI_EVNT_FIRST: rsmi_event_type_t = 0;
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_FIRST: rsmi_event_type_t = 0;
#[doc = "!< NOPs sent to neighbor 0"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_0_NOP_TX: rsmi_event_type_t = 0;
#[doc = "!< Outgoing requests to\n!< neighbor 0"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_0_REQUEST_TX: rsmi_event_type_t = 1;
#[doc = "!< Outgoing responses to\n!< neighbor 0"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_0_RESPONSE_TX: rsmi_event_type_t = 2;
#[doc = " @brief\n\n Data beats sent to neighbor 0; Each beat represents 32 bytes.<br><br>\n\n XGMI throughput can be calculated by multiplying a BEATs event\n such as ::RSMI_EVNT_XGMI_0_BEATS_TX by 32 and dividing by\n the time for which event collection occurred,\n ::rsmi_counter_value_t.time_running (which is in nanoseconds). To get\n bytes per second, multiply this value by 10<sup>9</sup>.<br>\n <br>\n Throughput = BEATS/time_running * 10<sup>9</sup>  (bytes/second)<br>"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_0_BEATS_TX: rsmi_event_type_t = 3;
#[doc = "!< NOPs sent to neighbor 1"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_1_NOP_TX: rsmi_event_type_t = 4;
#[doc = "!< Outgoing requests to\n!< neighbor 1"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_1_REQUEST_TX: rsmi_event_type_t = 5;
#[doc = "!< Outgoing responses to\n!< neighbor 1"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_1_RESPONSE_TX: rsmi_event_type_t = 6;
#[doc = "!< Data beats sent to\n!< neighbor 1; Each beat\n!< represents 32 bytes"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_1_BEATS_TX: rsmi_event_type_t = 7;
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_LAST: rsmi_event_type_t = 7;
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_FIRST: rsmi_event_type_t = 10;
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_0: rsmi_event_type_t = 10;
#[doc = "!< Outbound beats to neighbor 1"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_1: rsmi_event_type_t = 11;
#[doc = "!< Outbound beats to neighbor 2"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_2: rsmi_event_type_t = 12;
#[doc = "!< Outbound beats to neighbor 3"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_3: rsmi_event_type_t = 13;
#[doc = "!< Outbound beats to neighbor 4"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_4: rsmi_event_type_t = 14;
#[doc = "!< Outbound beats to neighbor 5"]
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_5: rsmi_event_type_t = 15;
pub const rsmi_event_type_t_RSMI_EVNT_XGMI_DATA_OUT_LAST: rsmi_event_type_t = 15;
pub const rsmi_event_type_t_RSMI_EVNT_LAST: rsmi_event_type_t = 15;
#[doc = " Event types\n @brief Event type enum. Events belonging to a particular event group\n ::rsmi_event_group_t should begin enumerating at the ::rsmi_event_group_t\n value for that group."]
pub type rsmi_event_type_t = ::std::os::raw::c_uint;
#[doc = "!< Start the counter"]
pub const rsmi_counter_command_t_RSMI_CNTR_CMD_START: rsmi_counter_command_t = 0;
#[doc = "!< Stop the counter; note that this should not\n!< be used before reading."]
pub const rsmi_counter_command_t_RSMI_CNTR_CMD_STOP: rsmi_counter_command_t = 1;
#[doc = " Event counter commands"]
pub type rsmi_counter_command_t = ::std::os::raw::c_uint;
#[doc = " Counter value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_counter_value_t {
    #[doc = "!< Counter value"]
    pub value: u64,
    #[doc = "!< Time that the counter was enabled\n!< (in nanoseconds)"]
    pub time_enabled: u64,
    #[doc = "!< Time that the counter was running\n!< (in nanoseconds)"]
    pub time_running: u64,
}
#[test]
fn bindgen_test_layout_rsmi_counter_value_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_counter_value_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_counter_value_t>(),
        24usize,
        concat!("Size of: ", stringify!(rsmi_counter_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_counter_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_counter_value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_counter_value_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_enabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_counter_value_t),
            "::",
            stringify!(time_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_running) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_counter_value_t),
            "::",
            stringify!(time_running)
        )
    );
}
#[doc = "!< VM page fault"]
pub const rsmi_evt_notification_type_t_RSMI_EVT_NOTIF_VMFAULT: rsmi_evt_notification_type_t = 1;
pub const rsmi_evt_notification_type_t_RSMI_EVT_NOTIF_FIRST: rsmi_evt_notification_type_t = 1;
pub const rsmi_evt_notification_type_t_RSMI_EVT_NOTIF_THERMAL_THROTTLE:
    rsmi_evt_notification_type_t = 2;
pub const rsmi_evt_notification_type_t_RSMI_EVT_NOTIF_GPU_PRE_RESET: rsmi_evt_notification_type_t =
    3;
pub const rsmi_evt_notification_type_t_RSMI_EVT_NOTIF_GPU_POST_RESET: rsmi_evt_notification_type_t =
    4;
pub const rsmi_evt_notification_type_t_RSMI_EVT_NOTIF_LAST: rsmi_evt_notification_type_t = 4;
#[doc = " Event notification event types"]
pub type rsmi_evt_notification_type_t = ::std::os::raw::c_uint;
#[doc = " Event notification data returned from event notification API"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_evt_notification_data_t {
    #[doc = "!< Index of device that corresponds to the event"]
    pub dv_ind: u32,
    #[doc = "!< Event type"]
    pub event: rsmi_evt_notification_type_t,
    #[doc = "!< Event message"]
    pub message: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rsmi_evt_notification_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_evt_notification_data_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_evt_notification_data_t>(),
        72usize,
        concat!("Size of: ", stringify!(rsmi_evt_notification_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_evt_notification_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rsmi_evt_notification_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dv_ind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_evt_notification_data_t),
            "::",
            stringify!(dv_ind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_evt_notification_data_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_evt_notification_data_t),
            "::",
            stringify!(message)
        )
    );
}
#[doc = "!< System clock"]
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_SYS: rsmi_clk_type_t = 0;
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_FIRST: rsmi_clk_type_t = 0;
#[doc = "!< Data Fabric clock (for ASICs\n!< running on a separate clock)"]
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_DF: rsmi_clk_type_t = 1;
#[doc = "!< Display Controller Engine clock"]
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_DCEF: rsmi_clk_type_t = 2;
#[doc = "!< SOC clock"]
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_SOC: rsmi_clk_type_t = 3;
#[doc = "!< Memory clock"]
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_MEM: rsmi_clk_type_t = 4;
#[doc = "!< PCIE clock"]
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_PCIE: rsmi_clk_type_t = 5;
pub const rsmi_clk_type_t_RSMI_CLK_TYPE_LAST: rsmi_clk_type_t = 4;
pub const rsmi_clk_type_t_RSMI_CLK_INVALID: rsmi_clk_type_t = 4294967295;
#[doc = " Clock types"]
pub type rsmi_clk_type_t = ::std::os::raw::c_uint;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_clk_type_t as rsmi_clk_type;
pub const rsmi_compute_partition_type_t_RSMI_COMPUTE_PARTITION_INVALID:
    rsmi_compute_partition_type_t = 0;
#[doc = "!< Core mode (CPX)- Per-chip XCC with\n!< shared memory"]
pub const rsmi_compute_partition_type_t_RSMI_COMPUTE_PARTITION_CPX: rsmi_compute_partition_type_t =
    1;
#[doc = "!< Single GPU mode (SPX)- All XCCs work\n!< together with shared memory"]
pub const rsmi_compute_partition_type_t_RSMI_COMPUTE_PARTITION_SPX: rsmi_compute_partition_type_t =
    2;
#[doc = "!< Dual GPU mode (DPX)- Half XCCs work\n!< together with shared memory"]
pub const rsmi_compute_partition_type_t_RSMI_COMPUTE_PARTITION_DPX: rsmi_compute_partition_type_t =
    3;
#[doc = "!< Triple GPU mode (TPX)- One-third XCCs\n!< work together with shared memory"]
pub const rsmi_compute_partition_type_t_RSMI_COMPUTE_PARTITION_TPX: rsmi_compute_partition_type_t =
    4;
#[doc = "!< Quad GPU mode (QPX)- Quarter XCCs\n!< work together with shared memory"]
pub const rsmi_compute_partition_type_t_RSMI_COMPUTE_PARTITION_QPX: rsmi_compute_partition_type_t =
    5;
#[doc = " @brief Compute Partition. This enum is used to identify\n various compute partitioning settings."]
pub type rsmi_compute_partition_type_t = ::std::os::raw::c_uint;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_compute_partition_type_t as rsmi_compute_partition_type;
pub const rsmi_memory_partition_type_t_RSMI_MEMORY_PARTITION_UNKNOWN: rsmi_memory_partition_type_t =
    0;
#[doc = "!< NPS1 - All CCD & XCD data is interleaved\n!< accross all 8 HBM stacks (all stacks/1)."]
pub const rsmi_memory_partition_type_t_RSMI_MEMORY_PARTITION_NPS1: rsmi_memory_partition_type_t = 1;
#[doc = "!< NPS2 - 2 sets of CCDs or 4 XCD interleaved\n!< accross the 4 HBM stacks per AID pair\n!< (8 stacks/2)."]
pub const rsmi_memory_partition_type_t_RSMI_MEMORY_PARTITION_NPS2: rsmi_memory_partition_type_t = 2;
#[doc = "!< NPS4 - Each XCD data is interleaved accross\n!< accross 2 (or single) HBM stacks\n!< (8 stacks/8 or 8 stacks/4)."]
pub const rsmi_memory_partition_type_t_RSMI_MEMORY_PARTITION_NPS4: rsmi_memory_partition_type_t = 3;
#[doc = "!< NPS8 - Each XCD uses a single HBM stack\n!< (8 stacks/8). Or each XCD uses a single\n!< HBM stack & CCDs share 2 non-interleaved\n!< HBM stacks on its AID\n!< (AID[1,2,3] = 6 stacks/6)."]
pub const rsmi_memory_partition_type_t_RSMI_MEMORY_PARTITION_NPS8: rsmi_memory_partition_type_t = 4;
#[doc = " @brief Memory Partitions. This enum is used to identify various\n memory partition types."]
pub type rsmi_memory_partition_type_t = ::std::os::raw::c_uint;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_memory_partition_type_t as rsmi_memory_partition_type;
#[doc = "!< Temperature current value."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_CURRENT: rsmi_temperature_metric_t = 0;
pub const rsmi_temperature_metric_t_RSMI_TEMP_FIRST: rsmi_temperature_metric_t = 0;
#[doc = "!< Temperature max value."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_MAX: rsmi_temperature_metric_t = 1;
#[doc = "!< Temperature min value."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_MIN: rsmi_temperature_metric_t = 2;
#[doc = "!< Temperature hysteresis value for max limit.\n!< (This is an absolute temperature, not a\n!< delta)."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_MAX_HYST: rsmi_temperature_metric_t = 3;
#[doc = "!< Temperature hysteresis value for min limit.\n!< (This is an absolute temperature,\n!<  not a delta)."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_MIN_HYST: rsmi_temperature_metric_t = 4;
#[doc = "!< Temperature critical max value, typically\n!<  greater than corresponding temp_max values."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_CRITICAL: rsmi_temperature_metric_t = 5;
#[doc = "!< Temperature hysteresis value for critical\n!<  limit. (This is an absolute temperature,\n!<  not a delta)."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_CRITICAL_HYST: rsmi_temperature_metric_t = 6;
#[doc = "!< Temperature emergency max value, for chips\n!<  supporting more than two upper temperature\n!<  limits. Must be equal or greater than\n!<  corresponding temp_crit values."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_EMERGENCY: rsmi_temperature_metric_t = 7;
#[doc = "!< Temperature hysteresis value for emergency\n!<  limit. (This is an absolute temperature,\n!<  not a delta)."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_EMERGENCY_HYST: rsmi_temperature_metric_t = 8;
#[doc = "!< Temperature critical min value, typically\n!<  lower than corresponding temperature\n!<  minimum values."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_CRIT_MIN: rsmi_temperature_metric_t = 9;
#[doc = "!< Temperature hysteresis value for critical\n!< minimum limit. (This is an absolute\n!< temperature, not a delta)."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_CRIT_MIN_HYST: rsmi_temperature_metric_t = 10;
#[doc = "!< Temperature offset which is added to the"]
pub const rsmi_temperature_metric_t_RSMI_TEMP_OFFSET: rsmi_temperature_metric_t = 11;
#[doc = "!< Historical minimum temperature."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_LOWEST: rsmi_temperature_metric_t = 12;
#[doc = "!< Historical maximum temperature."]
pub const rsmi_temperature_metric_t_RSMI_TEMP_HIGHEST: rsmi_temperature_metric_t = 13;
pub const rsmi_temperature_metric_t_RSMI_TEMP_LAST: rsmi_temperature_metric_t = 13;
#[doc = " @brief Temperature Metrics.  This enum is used to identify various\n temperature metrics. Corresponding values will be in millidegress\n Celcius."]
pub type rsmi_temperature_metric_t = ::std::os::raw::c_uint;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_temperature_metric_t as rsmi_temperature_metric;
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_FIRST: rsmi_temperature_type_t = 0;
#[doc = "!< Edge GPU temperature"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_EDGE: rsmi_temperature_type_t = 0;
#[doc = "!< Junction/hotspot\n!< temperature"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_JUNCTION: rsmi_temperature_type_t = 1;
#[doc = "!< VRAM temperature"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_MEMORY: rsmi_temperature_type_t = 2;
#[doc = "!< HBM temperature instance 0"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_HBM_0: rsmi_temperature_type_t = 3;
#[doc = "!< HBM temperature instance 1"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_HBM_1: rsmi_temperature_type_t = 4;
#[doc = "!< HBM temperature instance 2"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_HBM_2: rsmi_temperature_type_t = 5;
#[doc = "!< HBM temperature instance 3"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_HBM_3: rsmi_temperature_type_t = 6;
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_LAST: rsmi_temperature_type_t = 6;
#[doc = "!< Invalid type"]
pub const rsmi_temperature_type_t_RSMI_TEMP_TYPE_INVALID: rsmi_temperature_type_t = 4294967295;
#[doc = " @brief This enumeration is used to indicate from which part of the device a\n temperature reading should be obtained."]
pub type rsmi_temperature_type_t = ::std::os::raw::c_uint;
pub const rsmi_activity_metric_t_RSMI_ACTIVITY_GFX: rsmi_activity_metric_t = 1;
#[doc = "!< memory controller"]
pub const rsmi_activity_metric_t_RSMI_ACTIVITY_UMC: rsmi_activity_metric_t = 2;
#[doc = "!< UVD or VCN"]
pub const rsmi_activity_metric_t_RSMI_ACTIVITY_MM: rsmi_activity_metric_t = 4;
#[doc = " @brief Activity (Utilization) Metrics.  This enum is used to identify\n various activity metrics.\n"]
pub type rsmi_activity_metric_t = ::std::os::raw::c_uint;
#[doc = "!< Voltage current value."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_CURRENT: rsmi_voltage_metric_t = 0;
pub const rsmi_voltage_metric_t_RSMI_VOLT_FIRST: rsmi_voltage_metric_t = 0;
#[doc = "!< Voltage max value."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_MAX: rsmi_voltage_metric_t = 1;
#[doc = "!< Voltage critical min value."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_MIN_CRIT: rsmi_voltage_metric_t = 2;
#[doc = "!< Voltage min value."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_MIN: rsmi_voltage_metric_t = 3;
#[doc = "!< Voltage critical max value."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_MAX_CRIT: rsmi_voltage_metric_t = 4;
#[doc = "!< Average voltage."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_AVERAGE: rsmi_voltage_metric_t = 5;
#[doc = "!< Historical minimum voltage."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_LOWEST: rsmi_voltage_metric_t = 6;
#[doc = "!< Historical maximum voltage."]
pub const rsmi_voltage_metric_t_RSMI_VOLT_HIGHEST: rsmi_voltage_metric_t = 7;
pub const rsmi_voltage_metric_t_RSMI_VOLT_LAST: rsmi_voltage_metric_t = 7;
#[doc = " @brief Voltage Metrics.  This enum is used to identify various\n Volatge metrics. Corresponding values will be in millivolt.\n"]
pub type rsmi_voltage_metric_t = ::std::os::raw::c_uint;
pub const rsmi_voltage_type_t_RSMI_VOLT_TYPE_FIRST: rsmi_voltage_type_t = 0;
#[doc = "!< Vddgfx GPU\n!< voltage"]
pub const rsmi_voltage_type_t_RSMI_VOLT_TYPE_VDDGFX: rsmi_voltage_type_t = 0;
pub const rsmi_voltage_type_t_RSMI_VOLT_TYPE_LAST: rsmi_voltage_type_t = 0;
#[doc = "!< Invalid type"]
pub const rsmi_voltage_type_t_RSMI_VOLT_TYPE_INVALID: rsmi_voltage_type_t = 4294967295;
#[doc = " @brief This ennumeration is used to indicate which type of\n voltage reading should be obtained."]
pub type rsmi_voltage_type_t = ::std::os::raw::c_uint;
#[doc = "!< Custom Power Profile"]
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_CUSTOM_MASK:
    rsmi_power_profile_preset_masks_t = 1;
#[doc = "!< Video Power Profile"]
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_VIDEO_MASK:
    rsmi_power_profile_preset_masks_t = 2;
#[doc = "!< Power Saving Profile"]
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_POWER_SAVING_MASK:
    rsmi_power_profile_preset_masks_t = 4;
#[doc = "!< Compute Saving Profile"]
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_COMPUTE_MASK:
    rsmi_power_profile_preset_masks_t = 8;
#[doc = "!< VR Power Profile"]
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_VR_MASK:
    rsmi_power_profile_preset_masks_t = 16;
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_3D_FULL_SCR_MASK:
    rsmi_power_profile_preset_masks_t = 32;
#[doc = "!< Default Boot Up Profile"]
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_BOOTUP_DEFAULT:
    rsmi_power_profile_preset_masks_t = 64;
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_LAST:
    rsmi_power_profile_preset_masks_t = 64;
pub const rsmi_power_profile_preset_masks_t_RSMI_PWR_PROF_PRST_INVALID:
    rsmi_power_profile_preset_masks_t = 18446744073709551615;
#[doc = " @brief Pre-set Profile Selections. These bitmasks can be AND'd with the\n ::rsmi_power_profile_status_t.available_profiles returned from\n ::rsmi_dev_power_profile_presets_get to determine which power profiles\n are supported by the system."]
pub type rsmi_power_profile_preset_masks_t = ::std::os::raw::c_ulong;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_power_profile_preset_masks_t as rsmi_power_profile_preset_masks;
#[doc = "!< Used to indicate an\n!< invalid block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_INVALID: rsmi_gpu_block_t = 0;
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_FIRST: rsmi_gpu_block_t = 1;
#[doc = "!< UMC block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_UMC: rsmi_gpu_block_t = 1;
#[doc = "!< SDMA block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_SDMA: rsmi_gpu_block_t = 2;
#[doc = "!< GFX block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_GFX: rsmi_gpu_block_t = 4;
#[doc = "!< MMHUB block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_MMHUB: rsmi_gpu_block_t = 8;
#[doc = "!< ATHUB block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_ATHUB: rsmi_gpu_block_t = 16;
#[doc = "!< PCIE_BIF block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_PCIE_BIF: rsmi_gpu_block_t = 32;
#[doc = "!< HDP block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_HDP: rsmi_gpu_block_t = 64;
#[doc = "!< XGMI block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_XGMI_WAFL: rsmi_gpu_block_t = 128;
#[doc = "!< DF block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_DF: rsmi_gpu_block_t = 256;
#[doc = "!< SMN block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_SMN: rsmi_gpu_block_t = 512;
#[doc = "!< SEM block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_SEM: rsmi_gpu_block_t = 1024;
#[doc = "!< MP0 block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_MP0: rsmi_gpu_block_t = 2048;
#[doc = "!< MP1 block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_MP1: rsmi_gpu_block_t = 4096;
#[doc = "!< Fuse block"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_FUSE: rsmi_gpu_block_t = 8192;
#[doc = "!< The highest bit position\n!< for supported blocks"]
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_LAST: rsmi_gpu_block_t = 8192;
pub const rsmi_gpu_block_t_RSMI_GPU_BLOCK_RESERVED: rsmi_gpu_block_t = 9223372036854775808;
#[doc = " @brief This enum is used to identify different GPU blocks."]
pub type rsmi_gpu_block_t = ::std::os::raw::c_ulong;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_gpu_block_t as rsmi_gpu_block;
#[doc = "!< No current errors"]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_NONE: rsmi_ras_err_state_t = 0;
#[doc = "!< ECC is disabled"]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_DISABLED: rsmi_ras_err_state_t = 1;
#[doc = "!< ECC errors present, but type unknown"]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_PARITY: rsmi_ras_err_state_t = 2;
#[doc = "!< Single correctable error"]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_SING_C: rsmi_ras_err_state_t = 3;
#[doc = "!< Multiple uncorrectable errors"]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_MULT_UC: rsmi_ras_err_state_t = 4;
#[doc = "!< Firmware detected error and isolated\n!< page. Treat as uncorrectable."]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_POISON: rsmi_ras_err_state_t = 5;
#[doc = "!< ECC is enabled"]
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_ENABLED: rsmi_ras_err_state_t = 6;
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_LAST: rsmi_ras_err_state_t = 6;
pub const rsmi_ras_err_state_t_RSMI_RAS_ERR_STATE_INVALID: rsmi_ras_err_state_t = 4294967295;
#[doc = " @brief The current ECC state"]
pub type rsmi_ras_err_state_t = ::std::os::raw::c_uint;
pub const rsmi_memory_type_t_RSMI_MEM_TYPE_FIRST: rsmi_memory_type_t = 0;
#[doc = "!< VRAM memory"]
pub const rsmi_memory_type_t_RSMI_MEM_TYPE_VRAM: rsmi_memory_type_t = 0;
#[doc = "!< VRAM memory that is visible"]
pub const rsmi_memory_type_t_RSMI_MEM_TYPE_VIS_VRAM: rsmi_memory_type_t = 1;
#[doc = "!< GTT memory"]
pub const rsmi_memory_type_t_RSMI_MEM_TYPE_GTT: rsmi_memory_type_t = 2;
pub const rsmi_memory_type_t_RSMI_MEM_TYPE_LAST: rsmi_memory_type_t = 2;
#[doc = " @brief Types of memory"]
pub type rsmi_memory_type_t = ::std::os::raw::c_uint;
#[doc = "!< Index used for the minimum frequency value"]
pub const rsmi_freq_ind_t_RSMI_FREQ_IND_MIN: rsmi_freq_ind_t = 0;
#[doc = "!< Index used for the maximum frequency value"]
pub const rsmi_freq_ind_t_RSMI_FREQ_IND_MAX: rsmi_freq_ind_t = 1;
#[doc = "!< An invalid frequency index"]
pub const rsmi_freq_ind_t_RSMI_FREQ_IND_INVALID: rsmi_freq_ind_t = 4294967295;
#[doc = " @brief The values of this enum are used as frequency identifiers."]
pub type rsmi_freq_ind_t = ::std::os::raw::c_uint;
#[doc = " \\cond Ignore in docs."]
pub use self::rsmi_freq_ind_t as rsmi_freq_ind;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_FIRST: rsmi_fw_block_t = 0;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_ASD: rsmi_fw_block_t = 0;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_CE: rsmi_fw_block_t = 1;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_DMCU: rsmi_fw_block_t = 2;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_MC: rsmi_fw_block_t = 3;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_ME: rsmi_fw_block_t = 4;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_MEC: rsmi_fw_block_t = 5;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_MEC2: rsmi_fw_block_t = 6;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_MES: rsmi_fw_block_t = 7;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_MES_KIQ: rsmi_fw_block_t = 8;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_PFP: rsmi_fw_block_t = 9;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_RLC: rsmi_fw_block_t = 10;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_RLC_SRLC: rsmi_fw_block_t = 11;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_RLC_SRLG: rsmi_fw_block_t = 12;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_RLC_SRLS: rsmi_fw_block_t = 13;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_SDMA: rsmi_fw_block_t = 14;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_SDMA2: rsmi_fw_block_t = 15;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_SMC: rsmi_fw_block_t = 16;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_SOS: rsmi_fw_block_t = 17;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_TA_RAS: rsmi_fw_block_t = 18;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_TA_XGMI: rsmi_fw_block_t = 19;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_UVD: rsmi_fw_block_t = 20;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_VCE: rsmi_fw_block_t = 21;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_VCN: rsmi_fw_block_t = 22;
pub const rsmi_fw_block_t_RSMI_FW_BLOCK_LAST: rsmi_fw_block_t = 22;
#[doc = " @brief The values of this enum are used to identify the various firmware\n blocks."]
pub type rsmi_fw_block_t = ::std::os::raw::c_uint;
pub const rsmi_xgmi_status_t_RSMI_XGMI_STATUS_NO_ERRORS: rsmi_xgmi_status_t = 0;
pub const rsmi_xgmi_status_t_RSMI_XGMI_STATUS_ERROR: rsmi_xgmi_status_t = 1;
pub const rsmi_xgmi_status_t_RSMI_XGMI_STATUS_MULTIPLE_ERRORS: rsmi_xgmi_status_t = 2;
#[doc = " @brief XGMI Status"]
pub type rsmi_xgmi_status_t = ::std::os::raw::c_uint;
#[doc = " @brief Bitfield used in various RSMI calls"]
pub type rsmi_bit_field_t = u64;
#[doc = " \\cond Ignore in docs."]
pub type rsmi_bit_field = rsmi_bit_field_t;
#[doc = "!< Reserved. This gpu page is reserved\n!<  and not available for use"]
pub const rsmi_memory_page_status_t_RSMI_MEM_PAGE_STATUS_RESERVED: rsmi_memory_page_status_t = 0;
#[doc = "!< Pending. This gpu page is marked\n!<  as bad and will be marked reserved\n!<  at the next window."]
pub const rsmi_memory_page_status_t_RSMI_MEM_PAGE_STATUS_PENDING: rsmi_memory_page_status_t = 1;
#[doc = "!< Unable to reserve this page"]
pub const rsmi_memory_page_status_t_RSMI_MEM_PAGE_STATUS_UNRESERVABLE: rsmi_memory_page_status_t =
    2;
#[doc = " @brief Reserved Memory Page States"]
pub type rsmi_memory_page_status_t = ::std::os::raw::c_uint;
#[doc = "!< unknown type."]
pub const _RSMI_IO_LINK_TYPE_RSMI_IOLINK_TYPE_UNDEFINED: _RSMI_IO_LINK_TYPE = 0;
#[doc = "!< PCI Express"]
pub const _RSMI_IO_LINK_TYPE_RSMI_IOLINK_TYPE_PCIEXPRESS: _RSMI_IO_LINK_TYPE = 1;
#[doc = "!< XGMI"]
pub const _RSMI_IO_LINK_TYPE_RSMI_IOLINK_TYPE_XGMI: _RSMI_IO_LINK_TYPE = 2;
#[doc = "!< Number of IO Link types"]
pub const _RSMI_IO_LINK_TYPE_RSMI_IOLINK_TYPE_NUMIOLINKTYPES: _RSMI_IO_LINK_TYPE = 3;
#[doc = "!< Max of IO Link types"]
pub const _RSMI_IO_LINK_TYPE_RSMI_IOLINK_TYPE_SIZE: _RSMI_IO_LINK_TYPE = 4294967295;
#[doc = " @brief Types for IO Link"]
pub type _RSMI_IO_LINK_TYPE = ::std::os::raw::c_uint;
#[doc = " @brief Types for IO Link"]
pub use self::_RSMI_IO_LINK_TYPE as RSMI_IO_LINK_TYPE;
pub const RSMI_UTILIZATION_COUNTER_TYPE_RSMI_UTILIZATION_COUNTER_FIRST:
    RSMI_UTILIZATION_COUNTER_TYPE = 0;
pub const RSMI_UTILIZATION_COUNTER_TYPE_RSMI_COARSE_GRAIN_GFX_ACTIVITY:
    RSMI_UTILIZATION_COUNTER_TYPE = 0;
#[doc = "!< Memory Activity"]
pub const RSMI_UTILIZATION_COUNTER_TYPE_RSMI_COARSE_GRAIN_MEM_ACTIVITY:
    RSMI_UTILIZATION_COUNTER_TYPE = 1;
pub const RSMI_UTILIZATION_COUNTER_TYPE_RSMI_UTILIZATION_COUNTER_LAST:
    RSMI_UTILIZATION_COUNTER_TYPE = 1;
#[doc = " @brief The utilization counter type"]
pub type RSMI_UTILIZATION_COUNTER_TYPE = ::std::os::raw::c_uint;
#[doc = "!< Average Power"]
pub const RSMI_POWER_TYPE_RSMI_AVERAGE_POWER: RSMI_POWER_TYPE = 0;
#[doc = "!< Current / Instant Power"]
pub const RSMI_POWER_TYPE_RSMI_CURRENT_POWER: RSMI_POWER_TYPE = 1;
#[doc = "!< Invalid / Undetected Power"]
pub const RSMI_POWER_TYPE_RSMI_INVALID_POWER: RSMI_POWER_TYPE = 4294967295;
#[doc = " @brief Power types"]
pub type RSMI_POWER_TYPE = ::std::os::raw::c_uint;
#[doc = " @brief The utilization counter data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_utilization_counter_t {
    #[doc = "!< Utilization counter type"]
    pub type_: RSMI_UTILIZATION_COUNTER_TYPE,
    #[doc = "!< Utilization counter value"]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rsmi_utilization_counter_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_utilization_counter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_utilization_counter_t>(),
        16usize,
        concat!("Size of: ", stringify!(rsmi_utilization_counter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_utilization_counter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_utilization_counter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_utilization_counter_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_utilization_counter_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Reserved Memory Page Record"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_retired_page_record_t {
    #[doc = "!< Start address of page"]
    pub page_address: u64,
    #[doc = "!< Page size"]
    pub page_size: u64,
    #[doc = "!< Page \"reserved\" status"]
    pub status: rsmi_memory_page_status_t,
}
#[test]
fn bindgen_test_layout_rsmi_retired_page_record_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_retired_page_record_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_retired_page_record_t>(),
        24usize,
        concat!("Size of: ", stringify!(rsmi_retired_page_record_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_retired_page_record_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_retired_page_record_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_retired_page_record_t),
            "::",
            stringify!(page_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_retired_page_record_t),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_retired_page_record_t),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief This structure contains information about which power profiles are\n supported by the system for a given device, and which power profile is\n currently active."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_power_profile_status_t {
    #[doc = " Which profiles are supported by this system"]
    pub available_profiles: rsmi_bit_field_t,
    #[doc = " Which power profile is currently active"]
    pub current: rsmi_power_profile_preset_masks_t,
    #[doc = " How many power profiles are available"]
    pub num_profiles: u32,
}
#[test]
fn bindgen_test_layout_rsmi_power_profile_status_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_power_profile_status_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_power_profile_status_t>(),
        24usize,
        concat!("Size of: ", stringify!(rsmi_power_profile_status_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_power_profile_status_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_power_profile_status_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available_profiles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_power_profile_status_t),
            "::",
            stringify!(available_profiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_power_profile_status_t),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_profiles) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_power_profile_status_t),
            "::",
            stringify!(num_profiles)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_power_profile_status = rsmi_power_profile_status_t;
#[doc = " @brief This structure holds information about clock frequencies."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_frequencies_t {
    #[doc = " Deep Sleep frequency is only supported by some GPUs"]
    pub has_deep_sleep: bool,
    #[doc = " The number of supported frequencies"]
    pub num_supported: u32,
    #[doc = " The current frequency index"]
    pub current: u32,
    #[doc = " List of frequencies.\n Only the first num_supported frequencies are valid."]
    pub frequency: [u64; 33usize],
}
#[test]
fn bindgen_test_layout_rsmi_frequencies_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_frequencies_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_frequencies_t>(),
        280usize,
        concat!("Size of: ", stringify!(rsmi_frequencies_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_frequencies_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_frequencies_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_deep_sleep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_frequencies_t),
            "::",
            stringify!(has_deep_sleep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_supported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_frequencies_t),
            "::",
            stringify!(num_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_frequencies_t),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_frequencies_t),
            "::",
            stringify!(frequency)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_frequencies = rsmi_frequencies_t;
#[doc = " @brief This structure holds information about the possible PCIe\n bandwidths. Specifically, the possible transfer rates and their\n associated numbers of lanes are stored here."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_pcie_bandwidth_t {
    #[doc = " Transfer rates (T/s) that are possible"]
    pub transfer_rate: rsmi_frequencies_t,
    #[doc = " List of lanes for corresponding transfer rate.\n Only the first num_supported bandwidths are valid."]
    pub lanes: [u32; 33usize],
}
#[test]
fn bindgen_test_layout_rsmi_pcie_bandwidth_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_pcie_bandwidth_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_pcie_bandwidth_t>(),
        416usize,
        concat!("Size of: ", stringify!(rsmi_pcie_bandwidth_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_pcie_bandwidth_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_pcie_bandwidth_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_pcie_bandwidth_t),
            "::",
            stringify!(transfer_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lanes) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_pcie_bandwidth_t),
            "::",
            stringify!(lanes)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_pcie_bandwidth = rsmi_pcie_bandwidth_t;
#[doc = " @brief This structure holds information about the possible activity\n averages. Specifically, the utilization counters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_activity_metric_counter_t {
    pub average_gfx_activity: u16,
    #[doc = "!< memory controller"]
    pub average_umc_activity: u16,
    #[doc = "!< UVD or VCN"]
    pub average_mm_activity: u16,
}
#[test]
fn bindgen_test_layout_rsmi_activity_metric_counter_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_activity_metric_counter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_activity_metric_counter_t>(),
        6usize,
        concat!("Size of: ", stringify!(rsmi_activity_metric_counter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_activity_metric_counter_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rsmi_activity_metric_counter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_gfx_activity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_activity_metric_counter_t),
            "::",
            stringify!(average_gfx_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_umc_activity) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_activity_metric_counter_t),
            "::",
            stringify!(average_umc_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_mm_activity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_activity_metric_counter_t),
            "::",
            stringify!(average_mm_activity)
        )
    );
}
#[doc = " @brief This structure holds version information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_version_t {
    #[doc = "!< Major version"]
    pub major: u32,
    #[doc = "!< Minor version"]
    pub minor: u32,
    #[doc = "!< Patch, build  or stepping version"]
    pub patch: u32,
    #[doc = "!< Build string"]
    pub build: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rsmi_version_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_version_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_version_t>(),
        24usize,
        concat!("Size of: ", stringify!(rsmi_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_version_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_version_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_version_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_version_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_version_t),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_version_t),
            "::",
            stringify!(build)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_version = rsmi_version_t;
#[doc = " \\endcond\n**\n* @brief This structure represents a range (e.g., frequencies or voltages).\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_range_t {
    #[doc = "!< Lower bound of range"]
    pub lower_bound: u64,
    #[doc = "!< Upper bound of range"]
    pub upper_bound: u64,
}
#[test]
fn bindgen_test_layout_rsmi_range_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_range_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_range_t>(),
        16usize,
        concat!("Size of: ", stringify!(rsmi_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_range_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_bound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_range_t),
            "::",
            stringify!(lower_bound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper_bound) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_range_t),
            "::",
            stringify!(upper_bound)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_range = rsmi_range_t;
#[doc = " @brief This structure represents a point on the frequency-voltage plane."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_od_vddc_point_t {
    #[doc = "!< Frequency coordinate (in Hz)"]
    pub frequency: u64,
    #[doc = "!< Voltage coordinate (in mV)"]
    pub voltage: u64,
}
#[test]
fn bindgen_test_layout_rsmi_od_vddc_point_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_od_vddc_point_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_od_vddc_point_t>(),
        16usize,
        concat!("Size of: ", stringify!(rsmi_od_vddc_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_od_vddc_point_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_od_vddc_point_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_vddc_point_t),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_vddc_point_t),
            "::",
            stringify!(voltage)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_od_vddc_point = rsmi_od_vddc_point_t;
#[doc = " @brief This structure holds 2 ::rsmi_range_t's, one for frequency and one for\n voltage. These 2 ranges indicate the range of possible values for the\n corresponding ::rsmi_od_vddc_point_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_freq_volt_region_t {
    #[doc = "!< The frequency range for this VDDC Curve point"]
    pub freq_range: rsmi_range_t,
    #[doc = "!< The voltage range for this VDDC Curve point"]
    pub volt_range: rsmi_range_t,
}
#[test]
fn bindgen_test_layout_rsmi_freq_volt_region_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_freq_volt_region_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_freq_volt_region_t>(),
        32usize,
        concat!("Size of: ", stringify!(rsmi_freq_volt_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_freq_volt_region_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_freq_volt_region_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq_range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_freq_volt_region_t),
            "::",
            stringify!(freq_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volt_range) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_freq_volt_region_t),
            "::",
            stringify!(volt_range)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_freq_volt_region = rsmi_freq_volt_region_t;
#[doc = " ::RSMI_NUM_VOLTAGE_CURVE_POINTS number of ::rsmi_od_vddc_point_t's"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_od_volt_curve_t {
    #[doc = " Array of ::RSMI_NUM_VOLTAGE_CURVE_POINTS ::rsmi_od_vddc_point_t's that\n make up the voltage frequency curve points."]
    pub vc_points: [rsmi_od_vddc_point_t; 3usize],
}
#[test]
fn bindgen_test_layout_rsmi_od_volt_curve_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_od_volt_curve_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_od_volt_curve_t>(),
        48usize,
        concat!("Size of: ", stringify!(rsmi_od_volt_curve_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_od_volt_curve_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_od_volt_curve_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc_points) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_curve_t),
            "::",
            stringify!(vc_points)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_od_volt_curve = rsmi_od_volt_curve_t;
#[doc = " @brief This structure holds the frequency-voltage values for a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_od_volt_freq_data_t {
    #[doc = "!< The current SCLK frequency range"]
    pub curr_sclk_range: rsmi_range_t,
    #[doc = "!< The current MCLK frequency range;\n!< (upper bound only)"]
    pub curr_mclk_range: rsmi_range_t,
    #[doc = "!< The range possible of SCLK values"]
    pub sclk_freq_limits: rsmi_range_t,
    #[doc = "!< The range possible of MCLK values"]
    pub mclk_freq_limits: rsmi_range_t,
    #[doc = " @brief The current voltage curve"]
    pub curve: rsmi_od_volt_curve_t,
    #[doc = "!< The number of voltage curve regions"]
    pub num_regions: u32,
}
#[test]
fn bindgen_test_layout_rsmi_od_volt_freq_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_od_volt_freq_data_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_od_volt_freq_data_t>(),
        120usize,
        concat!("Size of: ", stringify!(rsmi_od_volt_freq_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_od_volt_freq_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_od_volt_freq_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_sclk_range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_freq_data_t),
            "::",
            stringify!(curr_sclk_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_mclk_range) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_freq_data_t),
            "::",
            stringify!(curr_mclk_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sclk_freq_limits) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_freq_data_t),
            "::",
            stringify!(sclk_freq_limits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mclk_freq_limits) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_freq_data_t),
            "::",
            stringify!(mclk_freq_limits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_freq_data_t),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_regions) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_od_volt_freq_data_t),
            "::",
            stringify!(num_regions)
        )
    );
}
#[doc = " \\cond Ignore in docs."]
pub type rsmi_od_volt_freq_data = rsmi_od_volt_freq_data_t;
#[doc = " @brief Size and version information of metrics data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct metrics_table_header_t {
    #[doc = " \\cond Ignore in docs."]
    pub structure_size: u16,
    pub format_revision: u8,
    pub content_revision: u8,
}
#[test]
fn bindgen_test_layout_metrics_table_header_t() {
    const UNINIT: ::std::mem::MaybeUninit<metrics_table_header_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<metrics_table_header_t>(),
        4usize,
        concat!("Size of: ", stringify!(metrics_table_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<metrics_table_header_t>(),
        2usize,
        concat!("Alignment of ", stringify!(metrics_table_header_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structure_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(metrics_table_header_t),
            "::",
            stringify!(structure_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_revision) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(metrics_table_header_t),
            "::",
            stringify!(format_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_revision) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(metrics_table_header_t),
            "::",
            stringify!(content_revision)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_gpu_metrics_t {
    #[doc = " \\cond Ignore in docs."]
    pub common_header: metrics_table_header_t,
    pub temperature_edge: u16,
    pub temperature_hotspot: u16,
    pub temperature_mem: u16,
    pub temperature_vrgfx: u16,
    pub temperature_vrsoc: u16,
    pub temperature_vrmem: u16,
    pub average_gfx_activity: u16,
    pub average_umc_activity: u16,
    pub average_mm_activity: u16,
    pub average_socket_power: u16,
    pub energy_accumulator: u64,
    pub system_clock_counter: u64,
    pub average_gfxclk_frequency: u16,
    pub average_socclk_frequency: u16,
    pub average_uclk_frequency: u16,
    pub average_vclk0_frequency: u16,
    pub average_dclk0_frequency: u16,
    pub average_vclk1_frequency: u16,
    pub average_dclk1_frequency: u16,
    pub current_gfxclk: u16,
    pub current_socclk: u16,
    pub current_uclk: u16,
    pub current_vclk0: u16,
    pub current_dclk0: u16,
    pub current_vclk1: u16,
    pub current_dclk1: u16,
    pub throttle_status: u32,
    pub current_fan_speed: u16,
    pub pcie_link_width: u16,
    pub pcie_link_speed: u16,
    pub gfx_activity_acc: u32,
    pub mem_activity_acc: u32,
    pub temperature_hbm: [u16; 4usize],
    pub firmware_timestamp: u64,
    pub voltage_soc: u16,
    pub voltage_gfx: u16,
    pub voltage_mem: u16,
    pub indep_throttle_status: u64,
    pub current_socket_power: u16,
    pub vcn_activity: [u16; 4usize],
    pub gfxclk_lock_status: u32,
    pub xgmi_link_width: u16,
    pub xgmi_link_speed: u16,
    pub pcie_bandwidth_acc: u64,
    pub pcie_bandwidth_inst: u64,
    pub pcie_l0_to_recov_count_acc: u64,
    pub pcie_replay_count_acc: u64,
    pub pcie_replay_rover_count_acc: u64,
    pub xgmi_read_data_acc: [u64; 8usize],
    pub xgmi_write_data_acc: [u64; 8usize],
    pub current_gfxclks: [u16; 8usize],
    pub current_socclks: [u16; 4usize],
    pub current_vclk0s: [u16; 4usize],
    pub current_dclk0s: [u16; 4usize],
    pub jpeg_activity: [u16; 32usize],
    pub pcie_nak_sent_count_acc: u32,
    pub pcie_nak_rcvd_count_acc: u32,
}
#[test]
fn bindgen_test_layout_rsmi_gpu_metrics_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_gpu_metrics_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_gpu_metrics_t>(),
        424usize,
        concat!("Size of: ", stringify!(rsmi_gpu_metrics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_gpu_metrics_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_gpu_metrics_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).common_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(common_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_edge) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_edge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_hotspot) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_hotspot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_mem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_vrgfx) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_vrgfx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_vrsoc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_vrsoc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_vrmem) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_vrmem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_gfx_activity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_gfx_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_umc_activity) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_umc_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_mm_activity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_mm_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_socket_power) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_socket_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).energy_accumulator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(energy_accumulator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_clock_counter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(system_clock_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_gfxclk_frequency) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_gfxclk_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_socclk_frequency) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_socclk_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_uclk_frequency) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_uclk_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_vclk0_frequency) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_vclk0_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_dclk0_frequency) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_dclk0_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_vclk1_frequency) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_vclk1_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).average_dclk1_frequency) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(average_dclk1_frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_gfxclk) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_gfxclk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_socclk) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_socclk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_uclk) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_uclk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_vclk0) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_vclk0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_dclk0) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_dclk0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_vclk1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_vclk1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_dclk1) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_dclk1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).throttle_status) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(throttle_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_fan_speed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_fan_speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_link_width) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_link_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_link_speed) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_link_speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gfx_activity_acc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(gfx_activity_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_activity_acc) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(mem_activity_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature_hbm) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(temperature_hbm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmware_timestamp) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(firmware_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltage_soc) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(voltage_soc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltage_gfx) as usize - ptr as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(voltage_gfx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltage_mem) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(voltage_mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indep_throttle_status) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(indep_throttle_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_socket_power) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_socket_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcn_activity) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(vcn_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gfxclk_lock_status) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(gfxclk_lock_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xgmi_link_width) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(xgmi_link_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xgmi_link_speed) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(xgmi_link_speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_bandwidth_acc) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_bandwidth_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_bandwidth_inst) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_bandwidth_inst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_l0_to_recov_count_acc) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_l0_to_recov_count_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_replay_count_acc) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_replay_count_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_replay_rover_count_acc) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_replay_rover_count_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xgmi_read_data_acc) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(xgmi_read_data_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xgmi_write_data_acc) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(xgmi_write_data_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_gfxclks) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_gfxclks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_socclks) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_socclks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_vclk0s) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_vclk0s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_dclk0s) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(current_dclk0s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jpeg_activity) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(jpeg_activity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_nak_sent_count_acc) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_nak_sent_count_acc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcie_nak_rcvd_count_acc) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_gpu_metrics_t),
            "::",
            stringify!(pcie_nak_rcvd_count_acc)
        )
    );
}
#[doc = " @brief This structure holds error counts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_error_count_t {
    #[doc = "!< Accumulated correctable errors"]
    pub correctable_err: u64,
    #[doc = "!< Accumulated uncorrectable errors"]
    pub uncorrectable_err: u64,
}
#[test]
fn bindgen_test_layout_rsmi_error_count_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_error_count_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_error_count_t>(),
        16usize,
        concat!("Size of: ", stringify!(rsmi_error_count_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_error_count_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_error_count_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correctable_err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_error_count_t),
            "::",
            stringify!(correctable_err)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncorrectable_err) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_error_count_t),
            "::",
            stringify!(uncorrectable_err)
        )
    );
}
#[doc = " @brief This structure contains information specific to a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_process_info_t {
    #[doc = "!< Process ID"]
    pub process_id: u32,
    #[doc = "!< PASID"]
    pub pasid: u32,
    #[doc = "!< VRAM usage"]
    pub vram_usage: u64,
    #[doc = "!< SDMA usage in microseconds"]
    pub sdma_usage: u64,
    #[doc = "!< Compute Unit usage in percent"]
    pub cu_occupancy: u32,
}
#[test]
fn bindgen_test_layout_rsmi_process_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<rsmi_process_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsmi_process_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(rsmi_process_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rsmi_process_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rsmi_process_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_process_info_t),
            "::",
            stringify!(process_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pasid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_process_info_t),
            "::",
            stringify!(pasid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vram_usage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_process_info_t),
            "::",
            stringify!(vram_usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdma_usage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_process_info_t),
            "::",
            stringify!(sdma_usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_occupancy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsmi_process_info_t),
            "::",
            stringify!(cu_occupancy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsmi_func_id_iter_handle {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to function-support object"]
pub type rsmi_func_id_iter_handle_t = *mut rsmi_func_id_iter_handle;
#[doc = " @brief This union holds the value of an ::rsmi_func_id_iter_handle_t. The\n value may be a function name, or an ennumerated variant value of types\n such as ::rsmi_memory_type_t, ::rsmi_temperature_metric_t, etc."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union id {
    #[doc = "!< uint64_t representation of value"]
    pub id: u64,
    #[doc = "!< name string (applicable to functions only)"]
    pub name: *const ::std::os::raw::c_char,
    pub __bindgen_anon_1: id__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union id__bindgen_ty_1 {
    pub memory_type: rsmi_memory_type_t,
    pub temp_metric: rsmi_temperature_metric_t,
    pub evnt_type: rsmi_event_type_t,
    pub evnt_group: rsmi_event_group_t,
    pub clk_type: rsmi_clk_type_t,
    pub fw_block: rsmi_fw_block_t,
    pub gpu_block_type: rsmi_gpu_block_t,
}
#[test]
fn bindgen_test_layout_id__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<id__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<id__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(id__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<id__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(id__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(memory_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temp_metric) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(temp_metric)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evnt_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(evnt_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evnt_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(evnt_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clk_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(clk_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fw_block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(fw_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_block_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(id__bindgen_ty_1),
            "::",
            stringify!(gpu_block_type)
        )
    );
}
#[test]
fn bindgen_test_layout_id() {
    const UNINIT: ::std::mem::MaybeUninit<id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<id>(),
        8usize,
        concat!("Size of: ", stringify!(id))
    );
    assert_eq!(
        ::std::mem::align_of::<id>(),
        8usize,
        concat!("Alignment of ", stringify!(id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(id), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(id), "::", stringify!(name))
    );
}
#[doc = " @brief This union holds the value of an ::rsmi_func_id_iter_handle_t. The\n value may be a function name, or an ennumerated variant value of types\n such as ::rsmi_memory_type_t, ::rsmi_temperature_metric_t, etc."]
pub type rsmi_func_id_value_t = id;
extern "C" {
    #[doc = "/\n/** @defgroup InitShutAdmin Initialization and Shutdown\n  These functions are used for initialization of ROCm SMI and clean up when\n  done.\n  @{\n/\n/**\n  @brief Initialize ROCm SMI.\n\n  @details When called, this initializes internal data structures,\n  including those corresponding to sources of information that SMI provides.\n\n  @param[in] init_flags Bit flags that tell SMI how to initialze. Values of\n  ::rsmi_init_flags_t may be OR'd together and passed through @p init_flags\n  to modify how RSMI initializes.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call."]
    pub fn rsmi_init(init_flags: u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Shutdown ROCm SMI.\n\n  @details Do any necessary clean up."]
    pub fn rsmi_shut_down() -> rsmi_status_t;
}
extern "C" {
    #[doc = "/\n/** @defgroup IDQuer Identifier Queries\n  These functions provide identification information.\n  @{\n/\n/**\n  @brief Get the number of devices that have monitor information.\n\n  @details The number of devices which have monitors is returned. Monitors\n  are referenced by the index which can be between 0 and @p num_devices - 1.\n\n  @param[inout] num_devices Caller provided pointer to uint32_t. Upon\n  successful call, the value num_devices will contain the number of monitor\n  devices.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call."]
    pub fn rsmi_num_monitor_devices(num_devices: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the device id associated with the device with provided device\n  index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the device id value to the uint64_t pointed to by\n  @p id. This ID is an identification of the type of device, so calling this\n  function for different devices will give the same value if they are kind\n  of device. Consequently, this function should not be used to distinguish\n  one device from another. rsmi_dev_pci_id_get() should be used to get a\n  unique identifier.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the device id will be\n  written\n If this parameter is nullptr, this function will return\n ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n provided arguments.\n\n @retval ::RSMI_STATUS_SUCCESS call was successful\n @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n support this function with the given arguments\n @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the device revision associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t to\n  which the revision will be written\n\n  @param[in] dv_ind a device index\n\n  @param[inout] revision a pointer to uint32_t to which the device revision\n  will be written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_revision_get(dv_ind: u32, revision: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the SKU for a desired device associated with the device with\n  provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a char @p sku,\n  this function will attempt to obtain the SKU from the Product Information\n  FRU chip, present on server ASICs. It will write the sku value to the\n  char array pointed to by @p sku.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] sku a pointer to char to which the sku will be written\n\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_sku_get(dv_ind: u32, sku: *mut ::std::os::raw::c_char) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the device vendor id associated with the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the device vendor id value to the uint64_t pointed\n  to by @p id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the device vendor id will\n  be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_vendor_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the name string of a gpu device.\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function\n  will write the name of the device (up to @p len characters) to the buffer\n  @p name.\n\n  If the integer ID associated with the device is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex device ID\n  as a string. Updating the system name files can be accompplished with\n  \"sudo update-pciids\".\n\n  @param[in] dv_ind a device index\n\n  @param[inout] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_name_get(
        dv_ind: u32,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the brand string of a gpu device.\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p brand, and a length of this buffer @p len, this function\n  will write the brand of the device (up to @p len characters) to the buffer\n  @p brand.\n\n  If the sku associated with the device is not found as one of the values\n  contained within rsmi_dev_brand_get, then this function will return the\n  device marketing name as a string instead of the brand name.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] brand a pointer to a caller provided char buffer to which the\n  brand will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p brand.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_brand_get(
        dv_ind: u32,
        brand: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the name string for a give vendor ID\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function will\n  write the name of the vendor (up to @p len characters) buffer @p name. The\n  @p id may be a device vendor or subsystem vendor ID.\n\n  If the integer ID associated with the vendor is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex vendor ID\n  as a string. Updating the system name files can be accompplished with\n  \"sudo update-pciids\".\n\n  @param[in] dv_ind a device index\n\n  @param[inout] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_vendor_name_get(
        dv_ind: u32,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the vram vendor string of a gpu device.\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p brand, and a length of this buffer @p len, this function\n  will write the vram vendor of the device (up to @p len characters) to the\n  buffer @p brand.\n\n  If the vram vendor for the device is not found as one of the values\n  contained within rsmi_dev_vram_vendor_get, then this function will return\n  the string 'unknown' instead of the vram vendor.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] brand a pointer to a caller provided char buffer to which the\n  vram vendor will be written\n\n  @param[in] len the length of the caller provided buffer @p brand.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_vram_vendor_get(
        dv_ind: u32,
        brand: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Get the serial number string for a device\n\n @details Given a device index @p dv_ind, a pointer to a buffer of chars\n @p serial_num, and the length of the provided buffer @p len, this function\n will write the serial number string (up to @p len characters) to the buffer\n pointed to by @p serial_num.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] serial_num a pointer to caller-provided memory to which the\n  serial number will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p serial_num.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_serial_number_get(
        dv_ind: u32,
        serial_num: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the subsystem device id associated with the device with\n  provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the subsystem device id value to the uint64_t\n  pointed to by @p id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the subsystem device id\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_subsystem_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the name string for the device subsytem\n\n  @details Given a device index @p dv_ind, a pointer to a caller provided\n  char buffer @p name, and a length of this buffer @p len, this function\n  will write the name of the device subsystem (up to @p len characters)\n  to the buffer @p name.\n\n  If the integer ID associated with the sub-system is not found in one of the\n  system files containing device name information (e.g.\n  /usr/share/misc/pci.ids), then this function will return the hex sub-system\n  ID as a string. Updating the system name files can be accompplished with\n  \"sudo update-pciids\".\n\n  @param[in] dv_ind a device index\n\n  @param[inout] name a pointer to a caller provided char buffer to which the\n  name will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written.\n"]
    pub fn rsmi_dev_subsystem_name_get(
        dv_ind: u32,
        name: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the drm minor number associated with this device\n\n  @details Given a device index @p dv_ind, find its render device file\n  /dev/dri/renderDN where N corresponds to its minor number.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] minor a pointer to a uint32_t into which minor number will\n  be copied\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_INIT_ERROR if failed to get minor number during\n  initialization.\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_drm_render_minor_get(dv_ind: u32, minor: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the device subsystem vendor id associated with the device with\n  provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p id,\n  this function will write the device subsystem vendor id value to the\n  uint64_t pointed to by @p id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the device subsystem vendor\n  id will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_subsystem_vendor_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get Unique ID\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t @p\n  id, this function will write the unique ID of the GPU pointed to @p\n  id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] id a pointer to uint64_t to which the unique ID of the GPU\n  is written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_unique_id_get(dv_ind: u32, id: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the XGMI physical id associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t to\n  which the XGMI physical id will be written\n\n  @param[in] dv_ind a device index\n\n  @param[inout] revision a pointer to uint32_t to which the XGMI physical id\n  will be written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_xgmi_physical_id_get(dv_ind: u32, id: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "/\n/** @defgroup PCIeQuer PCIe Queries\n  These functions provide information about PCIe.\n  @{\n/\n/**\n  @brief Get the list of possible PCIe bandwidths that are available.\n\n  @details Given a device index @p dv_ind and a pointer to a to an\n  ::rsmi_pcie_bandwidth_t structure @p bandwidth, this function will fill in\n  @p bandwidth with the possible T/s values and associated number of lanes,\n  and indication of the current selection.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] bandwidth a pointer to a caller provided\n  ::rsmi_pcie_bandwidth_t structure to which the frequency information will be\n  written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_UNEXPECTED_DATA Data read or provided was not as\n  expected\n"]
    pub fn rsmi_dev_pci_bandwidth_get(
        dv_ind: u32,
        bandwidth: *mut rsmi_pcie_bandwidth_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the unique PCI device identifier associated for a device\n\n  @details Give a device index @p dv_ind and a pointer to a uint64_t @p\n  bdfid, this function will write the Bus/Device/Function PCI identifier\n  (BDFID) associated with device @p dv_ind to the value pointed to by\n  @p bdfid.\n\n  The format of @p bdfid will be as follows:\n\n      BDFID = ((DOMAIN & 0xffffffff) << 32) | ((BUS & 0xff) << 8) |\n                                   ((DEVICE & 0x1f) <<3 ) | (FUNCTION & 0x7)\n\n  | Name     | Field   |\n  ---------- | ------- |\n  | Domain   | [64:32] |\n  | Reserved | [31:16] |\n  | Bus      | [15: 8] |\n  | Device   | [ 7: 3] |\n  | Function | [ 2: 0] |\n\n  @param[in] dv_ind a device index\n\n  @param[inout] bdfid a pointer to uint64_t to which the device bdfid value\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_pci_id_get(dv_ind: u32, bdfid: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the NUMA node associated with a device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p\n  numa_node, this function will retrieve the NUMA node value associated\n  with device @p dv_ind and store the value at location pointed to by\n  @p numa_node.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] numa_node pointer to location where NUMA node value will\n  be written.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_topo_numa_affinity_get(dv_ind: u32, numa_node: *mut i32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get PCIe traffic information\n\n  @details Give a device index @p dv_ind and pointers to a uint64_t's, @p\n  sent, @p received and @p max_pkt_sz, this function will write the number\n  of bytes sent and received in 1 second to @p sent and @p received,\n  respectively. The maximum possible packet size will be written to\n  @p max_pkt_sz.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] sent a pointer to uint64_t to which the number of bytes sent\n  will be written in 1 second. If pointer is NULL, it will be ignored.\n\n  @param[inout] received a pointer to uint64_t to which the number of bytes\n  received will be written. If pointer is NULL, it will be ignored.\n\n  @param[inout] max_pkt_sz a pointer to uint64_t to which the maximum packet\n  size will be written. If pointer is NULL, it will be ignored.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments"]
    pub fn rsmi_dev_pci_throughput_get(
        dv_ind: u32,
        sent: *mut u64,
        received: *mut u64,
        max_pkt_sz: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get PCIe replay counter\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t @p\n  counter, this function will write the sum of the number of NAK's received\n  by the GPU and the NAK's generated by the GPU to memory pointed to by @p\n  counter.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] counter a pointer to uint64_t to which the sum of the NAK's\n  received and generated by the GPU is written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_pci_replay_counter_get(dv_ind: u32, counter: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Control the set of allowed PCIe bandwidths that can be used.\n\n  @details Given a device index @p dv_ind and a 64 bit bitmask @p bw_bitmask,\n  this function will limit the set of allowable bandwidths. If a bit in @p\n  bw_bitmask has a value of 1, then the frequency (as ordered in an\n  ::rsmi_frequencies_t returned by ::rsmi_dev_gpu_clk_freq_get()) corresponding\n  to that bit index will be allowed.\n\n  This function will change the performance level to\n  ::RSMI_DEV_PERF_LEVEL_MANUAL in order to modify the set of allowable\n  band_widths. Caller will need to set to ::RSMI_DEV_PERF_LEVEL_AUTO in order\n  to get back to default state.\n\n  All bits with indices greater than or equal to the value of the\n  ::rsmi_frequencies_t::num_supported field of ::rsmi_pcie_bandwidth_t will be\n  ignored.\n\n  @param[in] dv_ind a device index\n\n  @param[in] bw_bitmask A bitmask indicating the indices of the\n  bandwidths that are to be enabled (1) and disabled (0). Only the lowest\n  ::rsmi_frequencies_t::num_supported (of ::rsmi_pcie_bandwidth_t) bits of\n  this mask are relevant.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_pci_bandwidth_set(dv_ind: u32, bw_bitmask: u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "/\n/** @defgroup PowerQuer Power Queries\n  These functions provide information about power usage.\n  @{\n/\n/**\n  @brief Get the average power consumption of the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t\n  @p power, this function will write the current average power consumption\n  (in microwatts) to the uint64_t pointed to by @p power.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] power a pointer to uint64_t to which the average power\n  consumption will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_ave_get(dv_ind: u32, sensor_ind: u32, power: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the current socket power (also known as instant\n  power) of the device index provided.\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t\n  @p socket_power, this function will write the current socket power\n  (in microwatts) to the uint64_t pointed to by @p socket_power.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] socket_power a pointer to uint64_t to which the current\n  socket power will be written to. If this parameter is nullptr,\n  this function will return ::RSMI_STATUS_INVALID_ARGS if the function is\n  supported with the provided, arguments and ::RSMI_STATUS_NOT_SUPPORTED\n  if it is not supported with the provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_current_socket_power_get(dv_ind: u32, socket_power: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief A generic get which attempts to retieve current socket power\n  (also known as instant power) of the device index provided, if not\n  supported tries to get average power consumed by device. Current\n  socket power is typically supported by newer devices, whereas average\n  power is generally reported on older devices. This function\n  aims to provide backwards compatability depending on device support.\n\n  @details Given a device index @p dv_ind, a pointer to a uint64_t\n  @p power, and @p type this function will write the current socket or\n  average power (in microwatts) to the uint64_t pointed to by @p power and\n  a pointer to its @p type RSMI_POWER_TYPE read.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] power a pointer to uint64_t to which the current or average\n  power will be written to. If this parameter is nullptr,\n  this function will return ::RSMI_STATUS_INVALID_ARGS if the function is\n  supported with the provided, arguments and ::RSMI_STATUS_NOT_SUPPORTED\n  if it is not supported with the provided arguments.\n\n  @param[inout] type a pointer to RSMI_POWER_TYPE object. Returns the type\n  of power retrieved from the device. Current power is ::RSMI_CURRENT_POWER\n  and average power is ::RSMI_AVERAGE_POWER. If an error occurs,\n  returns an invalid power type ::RSMI_INVALID_POWER.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_get(
        dv_ind: u32,
        power: *mut u64,
        type_: *mut RSMI_POWER_TYPE,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the energy accumulator counter of the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind, a pointer to a uint64_t\n  @p power, and a pointer to a uint64_t @p timestamp, this function will write\n  amount of energy consumed to the uint64_t pointed to by @p power,\n  and the timestamp to the uint64_t pointed to by @p timestamp.\n  The rsmi_dev_power_ave_get() is an average of a short time. This function\n  accumulates all energy consumed.\n\n  @param[in] dv_ind a device index\n  @param[inout] counter_resolution resolution of the counter @p power in\n  micro Joules\n\n  @param[inout] power a pointer to uint64_t to which the energy\n  counter will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] timestamp a pointer to uint64_t to which the timestamp\n  will be written. Resolution: 1 ns.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_energy_count_get(
        dv_ind: u32,
        power: *mut u64,
        counter_resolution: *mut f32,
        timestamp: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the cap on power which, when reached, causes the system to take\n  action to reduce power.\n\n  @details When power use rises above the value @p power, the system will\n  take action to reduce power use. The power level returned through\n  @p power will be in microWatts.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] cap a pointer to a uint64_t that indicates the power cap,\n  in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_cap_get(dv_ind: u32, sensor_ind: u32, cap: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the default power cap for the device specified by @p dv_ind.\n\n  @details The maximum power cap be temporarily changed by the user. However,\n  this function always returns the default reset power cap. The power level\n  returned through @p power will be in microWatts.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] default_cap a pointer to a uint64_t that indicates the default\n  power cap, in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_power_cap_default_get(dv_ind: u32, default_cap: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the range of valid values for the power cap\n\n  @details This function will return the maximum possible valid power cap\n  @p max and the minimum possible valid power cap @p min\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] max a pointer to a uint64_t that indicates the maximum\n  possible power cap, in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] min a pointer to a uint64_t that indicates the minimum\n  possible power cap, in microwatts\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_power_cap_range_get(
        dv_ind: u32,
        sensor_ind: u32,
        max: *mut u64,
        min: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "/\n/** @defgroup PowerCont Power Control\n  These functions provide ways to control power usage.\n  @{\n/\n/**\n  @brief Set the power cap value\n\n  @details This function will set the power cap to the provided value @p cap.\n  @p cap must be between the minimum and maximum power cap values set by the\n  system, which can be obtained from ::rsmi_dev_power_cap_range_get.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in] cap a uint64_t that indicates the desired power cap, in\n  microwatts\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_power_cap_set(dv_ind: u32, sensor_ind: u32, cap: u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Set the power profile\n\n  @details Given a device index @p dv_ind and a @p profile, this function will\n  attempt to set the current profile to the provided profile. The provided\n  profile must be one of the currently supported profiles, as indicated by a\n  call to ::rsmi_dev_power_profile_presets_get()\n\n  @param[in] dv_ind a device index\n\n  @param[in] reserved Not currently used. Set to 0.\n\n  @param[in] profile a ::rsmi_power_profile_preset_masks_t that hold the mask\n  of the desired new power profile\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_power_profile_set(
        dv_ind: u32,
        reserved: u32,
        profile: rsmi_power_profile_preset_masks_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the total amount of memory that exists\n\n  @details Given a device index @p dv_ind, a type of memory @p mem_type, and\n  a pointer to a uint64_t @p total, this function will write the total amount\n  of @p mem_type memory that exists to the location pointed to by @p total.\n\n  @param[in] dv_ind a device index\n\n  @param[in] mem_type The type of memory for which the total amount will be\n  found\n\n  @param[inout] total a pointer to uint64_t to which the total amount of\n  memory will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_memory_total_get(
        dv_ind: u32,
        mem_type: rsmi_memory_type_t,
        total: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the current memory usage\n\n  @details Given a device index @p dv_ind, a type of memory @p mem_type, and\n  a pointer to a uint64_t @p usage, this function will write the amount of\n  @p mem_type memory that that is currently being used to the location\n  pointed to by @p used.\n\n  @param[in] dv_ind a device index\n\n  @param[in] mem_type The type of memory for which the amount being used will\n  be found\n\n  @param[inout] used a pointer to uint64_t to which the amount of memory\n  currently being used will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_memory_usage_get(
        dv_ind: u32,
        mem_type: rsmi_memory_type_t,
        used: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get percentage of time any device memory is being used\n\n  @details Given a device index @p dv_ind, this function returns the\n  percentage of time that any device memory is being used for the specified\n  device.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] busy_percent a pointer to the uint32_t to which the busy\n  percent will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_memory_busy_percent_get(dv_ind: u32, busy_percent: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get information about reserved (\"retired\") memory pages\n\n  @details Given a device index @p dv_ind, this function returns retired page\n  information @p records corresponding to the device with the provided device\n  index @p dv_ind. The number of retired page records is returned through @p\n  num_pages. @p records may be NULL on input. In this case, the number of\n  records available for retrieval will be returned through @p num_pages.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] num_pages a pointer to a uint32. As input, the value passed\n  through this parameter is the number of ::rsmi_retired_page_record_t's that\n  may be safely written to the memory pointed to by @p records. This is the\n  limit on how many records will be written to @p records. On return, @p\n  num_pages will contain the number of records written to @p records, or the\n  number of records that could have been written if enough memory had been\n  provided.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] records A pointer to a block of memory to which the\n  ::rsmi_retired_page_record_t values will be written. This value may be NULL.\n  In this case, this function can be used to query how many records are\n  available to read.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if more records were available\n  than allowed by the provided, allocated memory."]
    pub fn rsmi_dev_memory_reserved_pages_get(
        dv_ind: u32,
        num_pages: *mut u32,
        records: *mut rsmi_retired_page_record_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @defgroup PhysQuer Physical State Queries\n  These functions provide information about the physical characteristics of\n  the device.\n  @{\n/\n/**\n  @brief Get the fan speed in RPMs of the device with the specified device\n  index and 0-based sensor index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t\n  @p speed, this function will write the current fan speed in RPMs to the\n  uint32_t pointed to by @p speed\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] speed a pointer to uint32_t to which the speed will be\n  written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_fan_rpms_get(dv_ind: u32, sensor_ind: u32, speed: *mut i64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the fan speed for the specified device as a value relative to\n  ::RSMI_MAX_FAN_SPEED\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t\n  @p speed, this function will write the current fan speed (a value\n  between 0 and the maximum fan speed, ::RSMI_MAX_FAN_SPEED) to the uint32_t\n  pointed to by @p speed\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] speed a pointer to uint32_t to which the speed will be\n  written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_fan_speed_get(dv_ind: u32, sensor_ind: u32, speed: *mut i64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the max. fan speed of the device with provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t\n  @p max_speed, this function will write the maximum fan speed possible to\n  the uint32_t pointed to by @p max_speed\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] max_speed a pointer to uint32_t to which the maximum speed\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_fan_speed_max_get(
        dv_ind: u32,
        sensor_ind: u32,
        max_speed: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the temperature metric value for the specified metric, from the\n  specified temperature sensor on the specified device.\n\n  @details Given a device index @p dv_ind, a sensor type @p sensor_type, a\n  ::rsmi_temperature_metric_t @p metric and a pointer to an int64_t @p\n  temperature, this function will write the value of the metric indicated by\n  @p metric and @p sensor_type to the memory location @p temperature.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_type part of device from which temperature should be\n  obtained. This should come from the enum ::rsmi_temperature_type_t\n\n  @param[in] metric enum indicated which temperature value should be\n  retrieved\n\n  @param[inout] temperature a pointer to int64_t to which the temperature\n  will be written, in millidegrees Celcius.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_temp_metric_get(
        dv_ind: u32,
        sensor_type: u32,
        metric: rsmi_temperature_metric_t,
        temperature: *mut i64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the voltage metric value for the specified metric, from the\n  specified voltage sensor on the specified device.\n\n  @details Given a device index @p dv_ind, a sensor type @p sensor_type, a\n  ::rsmi_voltage_metric_t @p metric and a pointer to an int64_t @p\n  voltage, this function will write the value of the metric indicated by\n  @p metric and @p sensor_type to the memory location @p voltage.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_type part of device from which voltage should be\n  obtained. This should come from the enum ::rsmi_voltage_type_t\n\n  @param[in] metric enum indicated which voltage value should be\n  retrieved\n\n  @param[inout] voltage a pointer to int64_t to which the voltage\n  will be written, in millivolts.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_volt_metric_get(
        dv_ind: u32,
        sensor_type: rsmi_voltage_type_t,
        metric: rsmi_voltage_metric_t,
        voltage: *mut i64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "/\n/** @defgroup PhysCont Physical State Control\n  These functions provide control over the physical state of a device.\n  @{\n/\n/**\n  @brief Reset the fan to automatic driver control\n\n  @details This function returns control of the fan to the system\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n"]
    pub fn rsmi_dev_fan_reset(dv_ind: u32, sensor_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Set the fan speed for the specified device with the provided speed,\n  in RPMs.\n\n  @details Given a device index @p dv_ind and a integer value indicating\n  speed @p speed, this function will attempt to set the fan speed to @p speed.\n  An error will be returned if the specified speed is outside the allowable\n  range for the device. The maximum value is 255 and the minimum is 0.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[in] speed the speed to which the function will attempt to set the fan\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_fan_speed_set(dv_ind: u32, sensor_ind: u32, speed: u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get percentage of time device is busy doing any processing\n\n  @details Given a device index @p dv_ind, this function returns the\n  percentage of time that the specified device is busy. The device is\n  considered busy if any one or more of its sub-blocks are working, and idle\n  if none of the sub-blocks are working.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] busy_percent a pointer to the uint32_t to which the busy\n  percent will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_busy_percent_get(dv_ind: u32, busy_percent: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get coarse grain utilization counter of the specified device\n\n  @details Given a device index @p dv_ind, the array of the utilization counters,\n  the size of the array, this function returns the coarse grain utilization counters\n  and timestamp.\n  The counter is the accumulated percentages. Every milliseconds the firmware calculates\n  % busy count and then accumulates that value in the counter. This provides minimally\n  invasive coarse grain GPU usage information.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] utilization_counters Multiple utilization counters can be retreived with a single\n  call. The caller must allocate enough space to the utilization_counters array. The caller also\n  needs to set valid RSMI_UTILIZATION_COUNTER_TYPE type for each element of the array.\n  ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments.\n\n  If the function reutrns RSMI_STATUS_SUCCESS, the counter will be set in the value field of\n  the rsmi_utilization_counter_t.\n\n  @param[in] count The size of utilization_counters array.\n\n  @param[inout] timestamp The timestamp when the counter is retreived. Resolution: 1 ns.\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_utilization_count_get(
        dv_ind: u32,
        utilization_counters: *mut rsmi_utilization_counter_t,
        count: u32,
        timestamp: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get activity metric average utilization counter of the specified device\n\n  @details Given a device index @p dv_ind, the activity metric type,\n  this function returns the requested utilization counters\n\n  @param[in] dv_ind a device index\n\n  @param[in] activity_metric_type a metric type\n\n  @param[inout] activity_metric_counter Multiple utilization counters can be retrieved with a single\n  call. The caller must allocate enough space to the rsmi_activity_metric_counter_t structure.\n\n  If the function returns RSMI_STATUS_SUCCESS, the requested type will be set in the corresponding\n  field of the counter will be set in the value field of\n  the activity_metric_counter_t.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_activity_metric_get(
        dv_ind: u32,
        activity_metric_type: rsmi_activity_metric_t,
        activity_metric_counter: *mut rsmi_activity_metric_counter_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get activity metric bandwidth average utilization counter of the specified device\n\n  @details Given a device index @p dv_ind, the activity metric type,\n  this function returns the requested utilization counters\n\n  @param[in] dv_ind a device index\n\n  @param[inout] avg_activity average bandwidth utilization counters can be retrieved\n\n  If the function returns RSMI_STATUS_SUCCESS, the requested type will be set in the corresponding\n  field of the counter will be set in the value field of\n  the activity_metric_counter_t.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_activity_avg_mm_get(dv_ind: u32, avg_activity: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the performance level of the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p\n  perf, this function will write the ::rsmi_dev_perf_level_t to the uint32_t\n  pointed to by @p perf\n\n  @param[in] dv_ind a device index\n\n  @param[inout] perf a pointer to ::rsmi_dev_perf_level_t to which the\n  performance level will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_perf_level_get(dv_ind: u32, perf: *mut rsmi_dev_perf_level_t) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Enter performance determinism mode with provided device index.\n\n  @details Given a device index @p dv_ind and @p clkvalue this function\n  will enable performance determinism mode, which enforces a GFXCLK frequency\n  SoftMax limit per GPU set by the user. This prevents the GFXCLK PLL from\n  stretching when running the same workload on different GPUS, making\n  performance variation minimal. This call will result in the performance\n  level ::rsmi_dev_perf_level_t of the device being\n  ::RSMI_DEV_PERF_LEVEL_DETERMINISM.\n\n  @param[in] dv_ind a device index\n\n  @param[in] clkvalue Softmax value for GFXCLK in MHz.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_perf_determinism_mode_set(dv_ind: u32, clkvalue: u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the overdrive percent associated with the device with provided\n  device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p od,\n  this function will write the overdrive percentage to the uint32_t pointed\n  to by @p od\n\n  @param[in] dv_ind a device index\n\n  @param[inout] od a pointer to uint32_t to which the overdrive percentage\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_overdrive_level_get(dv_ind: u32, od: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the memory clock overdrive percent associated with the device\n  with provided device index.\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t @p od,\n  this function will write the memory overdrive percentage to the uint32_t\n  pointed to by @p od\n\n  @param[in] dv_ind a device index\n\n  @param[inout] od a pointer to uint32_t to which the overdrive percentage\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_mem_overdrive_level_get(dv_ind: u32, od: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the list of possible system clock speeds of device for a\n  specified clock type.\n\n  @details Given a device index @p dv_ind, a clock type @p clk_type, and a\n  pointer to a to an ::rsmi_frequencies_t structure @p f, this function will\n  fill in @p f with the possible clock speeds, and indication of the current\n  clock speed selection.\n\n  @param[in] dv_ind a device index\n\n  @param[in] clk_type the type of clock for which the frequency is desired\n\n  @param[inout] f a pointer to a caller provided ::rsmi_frequencies_t structure\n  to which the frequency information will be written. Frequency values are in\n  Hz.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n  If multiple current frequencies are found, a warning is shown. If no\n  current frequency is found, it is reflected as -1. If frequencies are not\n  read from low to high a warning is shown as well.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_UNEXPECTED_DATA Data read or provided was not as\n  expected\n"]
    pub fn rsmi_dev_gpu_clk_freq_get(
        dv_ind: u32,
        clk_type: rsmi_clk_type_t,
        f: *mut rsmi_frequencies_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Reset the gpu associated with the device with provided device index\n\n  @details Given a device index @p dv_ind, this function will reset the GPU\n\n  @param[in] dv_ind a device index\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_gpu_reset(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief This function retrieves the voltage/frequency curve information\n\n  @details Given a device index @p dv_ind and a pointer to a\n  ::rsmi_od_volt_freq_data_t structure @p odv, this function will populate @p\n  odv. See ::rsmi_od_volt_freq_data_t for more details.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] odv a pointer to an ::rsmi_od_volt_freq_data_t structure\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_volt_info_get(
        dv_ind: u32,
        odv: *mut rsmi_od_volt_freq_data_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief This function retrieves the gpu metrics information\n\n  @details Given a device index @p dv_ind and a pointer to a\n  ::rsmi_gpu_metrics_t structure @p pgpu_metrics, this function will populate\n  @p pgpu_metrics. See ::rsmi_gpu_metrics_t for more details.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pgpu_metrics a pointer to an ::rsmi_gpu_metrics_t structure\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_gpu_metrics_info_get(
        dv_ind: u32,
        pgpu_metrics: *mut rsmi_gpu_metrics_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief This function sets the clock range information\n\n  @details Given a device index @p dv_ind, a minimum clock value @p minclkvalue,\n  a maximum clock value @p maxclkvalue and a clock type @p clkType this function\n  will set the sclk|mclk range\n\n  @param[in] dv_ind a device index\n\n  @param[in] minclkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] maxclkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] clkType RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_clk_range_set(
        dv_ind: u32,
        minclkvalue: u64,
        maxclkvalue: u64,
        clkType: rsmi_clk_type_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief This function sets the clock frequency information\n\n  @details Given a device index @p dv_ind, a frequency level @p level,\n  a clock value @p clkvalue and a clock type @p clkType this function\n  will set the sclk|mclk range\n\n  @param[in] dv_ind a device index\n\n  @param[in] level RSMI_FREQ_IND_MIN|RSMI_FREQ_IND_MAX to set the\n  minimum (0) or maximum (1) speed.\n\n  @param[in] clkvalue value to apply to the clock range. Frequency values\n  are in MHz.\n\n  @param[in] clkType RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_clk_info_set(
        dv_ind: u32,
        level: rsmi_freq_ind_t,
        clkvalue: u64,
        clkType: rsmi_clk_type_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief This function sets  1 of the 3 voltage curve points.\n\n  @details Given a device index @p dv_ind, a voltage point @p vpoint\n  and a voltage value @p voltvalue this function will set voltage curve point\n\n  @param[in] dv_ind a device index\n\n  @param[in] vpoint voltage point [0|1|2] on the voltage curve\n\n  @param[in] clkvalue clock value component of voltage curve point.\n  Frequency values are in MHz.\n\n  @param[in] voltvalue voltage value component of voltage curve point.\n  Voltage is in mV.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_volt_info_set(
        dv_ind: u32,
        vpoint: u32,
        clkvalue: u64,
        voltvalue: u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief This function will retrieve the current valid regions in the\n  frequency/voltage space.\n\n  @details Given a device index @p dv_ind, a pointer to an unsigned integer\n  @p num_regions and a buffer of ::rsmi_freq_volt_region_t structures, @p\n  buffer, this function will populate @p buffer with the current\n  frequency-volt space regions. The caller should assign @p buffer to memory\n  that can be written to by this function. The caller should also\n  indicate the number of ::rsmi_freq_volt_region_t structures that can safely\n  be written to @p buffer in @p num_regions.\n\n  The number of regions to expect this function provide (@p num_regions) can\n  be obtained by calling ::rsmi_dev_od_volt_info_get().\n\n  @param[in] dv_ind a device index\n\n  @param[inout] num_regions As input, this is the number of\n  ::rsmi_freq_volt_region_t structures that can be written to @p buffer. As\n  output, this is the number of ::rsmi_freq_volt_region_t structures that were\n  actually written.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[inout] buffer a caller provided buffer to which\n  ::rsmi_freq_volt_region_t structures will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_od_volt_curve_regions_get(
        dv_ind: u32,
        num_regions: *mut u32,
        buffer: *mut rsmi_freq_volt_region_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the list of available preset power profiles and an indication of\n  which profile is currently active.\n\n  @details Given a device index @p dv_ind and a pointer to a\n  ::rsmi_power_profile_status_t @p status, this function will set the bits of\n  the ::rsmi_power_profile_status_t.available_profiles bit field of @p status to\n  1 if the profile corresponding to the respective\n  ::rsmi_power_profile_preset_masks_t profiles are enabled. For example, if both\n  the VIDEO and VR power profiles are available selections, then\n  ::RSMI_PWR_PROF_PRST_VIDEO_MASK AND'ed with\n  ::rsmi_power_profile_status_t.available_profiles will be non-zero as will\n  ::RSMI_PWR_PROF_PRST_VR_MASK AND'ed with\n  ::rsmi_power_profile_status_t.available_profiles. Additionally,\n  ::rsmi_power_profile_status_t.current will be set to the\n  ::rsmi_power_profile_preset_masks_t of the profile that is currently active.\n\n  @param[in] dv_ind a device index\n\n  @param[in] sensor_ind a 0-based sensor index. Normally, this will be 0.\n  If a device has more than one sensor, it could be greater than 0.\n\n  @param[inout] status a pointer to ::rsmi_power_profile_status_t that will be\n  populated by a call to this function\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_power_profile_presets_get(
        dv_ind: u32,
        sensor_ind: u32,
        status: *mut rsmi_power_profile_status_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @defgroup PerfCont Clock, Power and Performance Control\n  These functions provide control over clock frequencies, power and\n  performance.\n  @{\n/\n/**\n  @brief Set the PowerPlay performance level associated with the device with\n  provided device index with the provided value.\n\n  @deprecated ::rsmi_dev_perf_level_set_v1() is preferred, with an\n  interface that more closely  matches the rest of the rocm_smi API.\n\n  @details Given a device index @p dv_ind and an ::rsmi_dev_perf_level_t @p\n  perf_level, this function will set the PowerPlay performance level for the\n  device to the value @p perf_lvl.\n\n  @param[in] dv_ind a device index\n\n  @param[in] perf_lvl the value to which the performance level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_perf_level_set(dv_ind: u32, perf_lvl: rsmi_dev_perf_level_t) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Set the PowerPlay performance level associated with the device with\n  provided device index with the provided value.\n\n  @details Given a device index @p dv_ind and an ::rsmi_dev_perf_level_t @p\n  perf_level, this function will set the PowerPlay performance level for the\n  device to the value @p perf_lvl.\n\n  @param[in] dv_ind a device index\n\n  @param[in] perf_lvl the value to which the performance level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_perf_level_set_v1(
        dv_ind: u32,
        perf_lvl: rsmi_dev_perf_level_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Set the overdrive percent associated with the device with provided\n  device index with the provided value. See details for WARNING.\n\n  @deprecated This function is deprecated. ::rsmi_dev_overdrive_level_set_v1\n  has the same functionaltiy, with an interface that more closely\n  matches the rest of the rocm_smi API.\n\n  @details Given a device index @p dv_ind and an overdrive level @p od,\n  this function will set the overdrive level for the device to the value\n  @p od. The overdrive level is an integer value between 0 and 20, inclusive,\n  which represents the overdrive percentage; e.g., a value of 5 specifies\n  an overclocking of 5%.\n\n  The overdrive level is specific to the gpu system clock.\n\n  The overdrive level is the percentage above the maximum Performance Level\n  to which overclocking will be limited. The overclocking percentage does\n  not apply to clock speeds other than the maximum. This percentage is\n  limited to 20%.\n\n   ******WARNING******\n  Operating your AMD GPU outside of official AMD specifications or outside of\n  factory settings, including but not limited to the conducting of\n  overclocking (including use of this overclocking software, even if such\n  software has been directly or indirectly provided by AMD or otherwise\n  affiliated in any way with AMD), may cause damage to your AMD GPU, system\n  components and/or result in system failure, as well as cause other problems.\n  DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS\n  OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT\n  WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S\n  WARRANTY. Please use this utility with caution.\n\n  @param[in] dv_ind a device index\n\n  @param[in] od the value to which the overdrive level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_overdrive_level_set(dv_ind: u32, od: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Set the overdrive percent associated with the device with provided\n  device index with the provided value. See details for WARNING.\n\n  @details Given a device index @p dv_ind and an overdrive level @p od,\n  this function will set the overdrive level for the device to the value\n  @p od. The overdrive level is an integer value between 0 and 20, inclusive,\n  which represents the overdrive percentage; e.g., a value of 5 specifies\n  an overclocking of 5%.\n\n  The overdrive level is specific to the gpu system clock.\n\n  The overdrive level is the percentage above the maximum Performance Level\n  to which overclocking will be limited. The overclocking percentage does\n  not apply to clock speeds other than the maximum. This percentage is\n  limited to 20%.\n\n   ******WARNING******\n  Operating your AMD GPU outside of official AMD specifications or outside of\n  factory settings, including but not limited to the conducting of\n  overclocking (including use of this overclocking software, even if such\n  software has been directly or indirectly provided by AMD or otherwise\n  affiliated in any way with AMD), may cause damage to your AMD GPU, system\n  components and/or result in system failure, as well as cause other problems.\n  DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS\n  OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT\n  WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S\n  WARRANTY. Please use this utility with caution.\n\n  @param[in] dv_ind a device index\n\n  @param[in] od the value to which the overdrive level should be set\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_overdrive_level_set_v1(dv_ind: u32, od: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Control the set of allowed frequencies that can be used for the\n specified clock.\n\n @details Given a device index @p dv_ind, a clock type @p clk_type, and a\n 64 bit bitmask @p freq_bitmask, this function will limit the set of\n allowable frequencies. If a bit in @p freq_bitmask has a value of 1, then\n the frequency (as ordered in an ::rsmi_frequencies_t returned by\n rsmi_dev_gpu_clk_freq_get()) corresponding to that bit index will be\n allowed.\n\n This function will change the performance level to\n ::RSMI_DEV_PERF_LEVEL_MANUAL in order to modify the set of allowable\n frequencies. Caller will need to set to ::RSMI_DEV_PERF_LEVEL_AUTO in order\n to get back to default state.\n\n All bits with indices greater than or equal to\n ::rsmi_frequencies_t::num_supported will be ignored.\n\n  @param[in] dv_ind a device index\n\n  @param[in] clk_type the type of clock for which the set of frequencies\n  will be modified\n\n  @param[in] freq_bitmask A bitmask indicating the indices of the\n  frequencies that are to be enabled (1) and disabled (0). Only the lowest\n  ::rsmi_frequencies_t.num_supported bits of this mask are relevant.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_gpu_clk_freq_set(
        dv_ind: u32,
        clk_type: rsmi_clk_type_t,
        freq_bitmask: u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Get the build version information for the currently running build of\n RSMI.\n\n @details  Get the major, minor, patch and build string for RSMI build\n currently in use through @p version\n\n @param[inout] version A pointer to an ::rsmi_version_t structure that will\n be updated with the version information upon return.\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n"]
    pub fn rsmi_version_get(version: *mut rsmi_version_t) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the driver version string for the current system.\n\n  @details Given a software component @p component, a pointer to a char\n  buffer, @p ver_str, this function will write the driver version string\n  (up to @p len characters) for the current system to @p ver_str. The caller\n  must ensure that it is safe to write at least @p len characters to @p\n  ver_str.\n\n  @param[in] component The component for which the version string is being\n  requested\n\n  @param[inout] ver_str A pointer to a buffer of char's to which the version\n  of @p component will be written\n\n  @param[in] len the length of the caller provided buffer @p name.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire name. In this case, only @p len bytes will\n  be written."]
    pub fn rsmi_version_str_get(
        component: rsmi_sw_component_t,
        ver_str: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the VBIOS identifer string\n\n  @details Given a device ID @p dv_ind, and a pointer to a char buffer,\n  @p vbios, this function will write the VBIOS string (up to @p len\n  characters) for device @p dv_ind to @p vbios. The caller must ensure that\n  it is safe to write at least @p len characters to @p vbios.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] vbios A pointer to a buffer of char's to which the VBIOS name\n  will be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @param[in] len The number of char's pointed to by @p vbios which can safely\n  be written to by this function.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_vbios_version_get(
        dv_ind: u32,
        vbios: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the firmware versions for a device\n\n  @details Given a device ID @p dv_ind, and a pointer to a uint64_t,\n  @p fw_version, this function will write the FW Versions as a string (up to @p len\n  characters) for device @p dv_ind to @p vbios. The caller must ensure that\n  it is safe to write at least @p len characters to @p vbios.\n\n  @param[in] dv_ind a device index\n\n  @param[in] block The firmware block for which the version is being requested\n\n  @param[inout] fw_version The version for the firmware block\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_firmware_version_get(
        dv_ind: u32,
        block: rsmi_fw_block_t,
        fw_version: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the error counts for a GPU block\n\n  @details Given a device index @p dv_ind, an ::rsmi_gpu_block_t @p block and a\n  pointer to an ::rsmi_error_count_t @p ec, this function will write the error\n  count values for the GPU block indicated by @p block to memory pointed to by\n  @p ec.\n\n  @param[in] dv_ind a device index\n\n  @param[in] block The block for which error counts should be retrieved\n\n  @param[inout] ec A pointer to an ::rsmi_error_count_t to which the error\n  counts should be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_ecc_count_get(
        dv_ind: u32,
        block: rsmi_gpu_block_t,
        ec: *mut rsmi_error_count_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the enabled ECC bit-mask\n\n  @details Given a device index @p dv_ind, and a pointer to a uint64_t @p\n  enabled_mask, this function will write bits to memory pointed to by\n  @p enabled_blocks. Upon a successful call, @p enabled_blocks can then be\n  AND'd with elements of the ::rsmi_gpu_block_t ennumeration to determine if\n  the corresponding block has ECC enabled. Note that whether a block has ECC\n  enabled or not in the device is independent of whether there is kernel\n  support for error counting for that block. Although a block may be enabled,\n  but there may not be kernel support for reading error counters for that\n  block.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] enabled_blocks A pointer to a uint64_t to which the enabled\n  blocks bits will be written.\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_dev_ecc_enabled_get(dv_ind: u32, enabled_blocks: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the ECC status for a GPU block\n\n  @details Given a device index @p dv_ind, an ::rsmi_gpu_block_t @p block and\n  a pointer to an ::rsmi_ras_err_state_t @p state, this function will write\n  the current state for the GPU block indicated by @p block to memory pointed\n  to by @p state.\n\n  @param[in] dv_ind a device index\n\n  @param[in] block The block for which error counts should be retrieved\n\n  @param[inout] state A pointer to an ::rsmi_ras_err_state_t to which the\n  ECC state should be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_ecc_status_get(
        dv_ind: u32,
        block: rsmi_gpu_block_t,
        state: *mut rsmi_ras_err_state_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get a description of a provided RSMI error status\n\n  @details Set the provided pointer to a const char *, @p status_string, to\n  a string containing a description of the provided error code @p status.\n\n  @param[in] status The error status for which a description is desired\n\n  @param[inout] status_string A pointer to a const char * which will be made\n  to point to a description of the provided error code\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n"]
    pub fn rsmi_status_string(
        status: rsmi_status_t,
        status_string: *mut *const ::std::os::raw::c_char,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Tell if an event group is supported by a given device\n\n  @details Given a device index @p dv_ind and an event group specifier @p\n  group, tell if @p group type events are supported by the device associated\n  with @p dv_ind\n\n  @param[in] dv_ind device index of device being queried\n\n  @param[in] group ::rsmi_event_group_t identifier of group for which support\n  is being queried\n\n  @retval ::RSMI_STATUS_SUCCESS if the device associatee with @p dv_ind\n  support counting events of the type indicated by @p group.\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  group\n"]
    pub fn rsmi_dev_counter_group_supported(
        dv_ind: u32,
        group: rsmi_event_group_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Create a performance counter object\n\n  @details Create a performance counter object of type @p type for the device\n  with a device index of @p dv_ind, and write a handle to the object to the\n  memory location pointed to by @p evnt_handle. @p evnt_handle can be used\n  with other performance event operations. The handle should be deallocated\n  with ::rsmi_dev_counter_destroy() when no longer needed.\n\n  @param[in] dv_ind a device index\n\n  @param[in] type the ::rsmi_event_type_t of performance event to create\n\n  @param[inout] evnt_handle A pointer to a ::rsmi_event_handle_t which will be\n  associated with a newly allocated counter\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_OUT_OF_RESOURCES unable to allocate memory for counter\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_counter_create(
        dv_ind: u32,
        type_: rsmi_event_type_t,
        evnt_handle: *mut rsmi_event_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Deallocate a performance counter object\n\n  @details Deallocate the performance counter object with the provided\n  ::rsmi_event_handle_t @p evnt_handle\n\n  @param[in] evnt_handle handle to event object to be deallocated\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_dev_counter_destroy(evnt_handle: rsmi_event_handle_t) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Issue performance counter control commands\n\n  @details Issue a command @p cmd on the event counter associated with the\n  provided handle @p evt_handle.\n\n  @param[in] evt_handle an event handle\n\n  @param[in] cmd The event counter command to be issued\n\n  @param[inout] cmd_args Currently not used. Should be set to NULL.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_counter_control(
        evt_handle: rsmi_event_handle_t,
        cmd: rsmi_counter_command_t,
        cmd_args: *mut ::std::os::raw::c_void,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Read the current value of a performance counter\n\n  @details Read the current counter value of the counter associated with the\n  provided handle @p evt_handle and write the value to the location pointed\n  to by @p value.\n\n  @param[in] evt_handle an event handle\n\n  @param[inout] value pointer to memory of size of ::rsmi_counter_value_t to\n  which the counter value will be written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n"]
    pub fn rsmi_counter_read(
        evt_handle: rsmi_event_handle_t,
        value: *mut rsmi_counter_value_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the number of currently available counters\n\n  @details Given a device index @p dv_ind, a performance event group @p grp,\n  and a pointer to a uint32_t @p available, this function will write the\n  number of @p grp type counters that are available on the device with index\n  @p dv_ind to the memory that @p available points to.\n\n  @param[in] dv_ind a device index\n\n  @param[in] grp an event device group\n\n  @param[inout] available A pointer to a uint32_t to which the number of\n  available counters will be written\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_counter_available_counters_get(
        dv_ind: u32,
        grp: rsmi_event_group_t,
        available: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get process information about processes currently using GPU\n\n  @details Given a non-NULL pointer to an array @p procs of\n  ::rsmi_process_info_t's, of length *@p num_items, this function will write\n  up to *@p num_items instances of ::rsmi_process_info_t to the memory pointed\n  to by @p procs. These instances contain information about each process\n  utilizing a GPU. If @p procs is not NULL, @p num_items will be updated with\n  the number of processes actually written. If @p procs is NULL, @p num_items\n  will be updated with the number of processes for which there is current\n  process information. Calling this function with @p procs being NULL is a way\n  to determine how much memory should be allocated for when @p procs is not\n  NULL.\n\n  @param[inout] procs a pointer to memory provided by the caller to which\n  process information will be written. This may be NULL in which case only @p\n  num_items will be updated with the number of processes found.\n\n  @param[inout] num_items A pointer to a uint32_t, which on input, should\n  contain the amount of memory in ::rsmi_process_info_t's which have been\n  provided by the @p procs argument. On output, if @p procs is non-NULL, this\n  will be updated with the number ::rsmi_process_info_t structs actually\n  written. If @p procs is NULL, this argument will be updated with the number\n  processes for which there is information.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if there were more\n  processes for which information was available, but not enough space was\n  provided as indicated by @p procs and @p num_items, on input."]
    pub fn rsmi_compute_process_info_get(
        procs: *mut rsmi_process_info_t,
        num_items: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get process information about a specific process\n\n  @details Given a pointer to an ::rsmi_process_info_t @p proc and a process\n  id\n  @p pid, this function will write the process information for @p pid, if\n  available, to the memory pointed to by @p proc.\n\n  @param[in] pid The process ID for which process information is being\n  requested\n\n  @param[inout] proc a pointer to a ::rsmi_process_info_t to which\n  process information for @p pid will be written if it is found.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_NOT_FOUND is returned if there was no process\n  information\n  found for the provided @p pid\n"]
    pub fn rsmi_compute_process_info_by_pid_get(
        pid: u32,
        proc_: *mut rsmi_process_info_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the device indices currently being used by a process\n\n  @details Given a process id @p pid, a non-NULL pointer to an array of\n  uint32_t's @p dv_indices of length *@p num_devices, this function will\n  write up to @p num_devices device indices to the memory pointed to by\n  @p dv_indices. If @p dv_indices is not NULL, @p num_devices will be\n  updated with the number of gpu's currently being used by process @p pid.\n  If @p dv_indices is NULL, @p dv_indices will be updated with the number of\n  gpus currently being used by @p pid. Calling this function with @p\n  dv_indices being NULL is a way to determine how much memory is required\n  for when @p dv_indices is not NULL.\n\n  @param[in] pid The process id of the process for which the number of gpus\n  currently being used is requested\n\n  @param[inout] dv_indices a pointer to memory provided by the caller to\n  which indices of devices currently being used by the process will be\n  written. This may be NULL in which case only @p num_devices will be\n  updated with the number of devices being used.\n\n  @param[inout] num_devices A pointer to a uint32_t, which on input, should\n  contain the amount of memory in uint32_t's which have been provided by the\n  @p dv_indices argument. On output, if @p dv_indices is non-NULL, this will\n  be updated with the number uint32_t's actually written. If @p dv_indices is\n  NULL, this argument will be updated with the number devices being used.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if there were more\n  gpu indices that could have been written, but not enough space was\n  provided as indicated by @p dv_indices and @p num_devices, on input.\n"]
    pub fn rsmi_compute_process_gpus_get(
        pid: u32,
        dv_indices: *mut u32,
        num_devices: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the info of a process on a specific device.\n\n  @details Given a process id @p pid, a @p dv_ind, this function will\n  write the process information for pid on the device, if available, to\n  the memory pointed to by @p proc.\n\n  @param[in] pid The process id of the process for which the gpu\n  currently being used is requested.\n\n  @param[in] dv_ind a device index where the process running on.\n\n  @param[inout] proc a pointer to memory provided by the caller to which\n  process information will be written.\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_compute_process_info_by_device_get(
        pid: u32,
        dv_ind: u32,
        proc_: *mut rsmi_process_info_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the XGMI error status for a device\n\n  @details Given a device index @p dv_ind, and a pointer to an\n  ::rsmi_xgmi_status_t @p status, this function will write the current XGMI\n  error state ::rsmi_xgmi_status_t for the device @p dv_ind to the memory\n  pointed to by @p status.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] status A pointer to an ::rsmi_xgmi_status_t to which the\n  XGMI error state should be written\n  If this parameter is nullptr, this function will return\n  ::RSMI_STATUS_INVALID_ARGS if the function is supported with the provided,\n  arguments and ::RSMI_STATUS_NOT_SUPPORTED if it is not supported with the\n  provided arguments.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_xgmi_error_status(
        dv_ind: u32,
        status: *mut rsmi_xgmi_status_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Reset the XGMI error status for a device\n\n @details Given a device index @p dv_ind, this function will reset the\n current XGMI error state ::rsmi_xgmi_status_t for the device @p dv_ind to\n rsmi_xgmi_status_t::RSMI_XGMI_STATUS_NO_ERRORS\n\n @param[in] dv_ind a device index\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_xgmi_error_reset(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the XGMI hive id for a device\n\n  @details Given a device index @p dv_ind, and a pointer to an\n  uint64_t @p hive_id, this function will write the current XGMI\n  hive id for the device @p dv_ind to the memory pointed to by @p hive_id.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] hive_id A pointer to an uint64_t to which the XGMI hive id\n  should be written\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function with the given arguments\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_dev_xgmi_hive_id_get(dv_ind: u32, hive_id: *mut u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the NUMA CPU node number for a device\n\n  @details Given a device index @p dv_ind, and a pointer to an\n  uint32_t @p numa_node, this function will write the\n  node number of NUMA CPU for the device @p dv_ind to the memory\n  pointed to by @p numa_node.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] numa_node A pointer to an uint32_t to which the\n  numa node number should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_topo_get_numa_node_number(dv_ind: u32, numa_node: *mut u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the weight for a connection between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst, and a pointer to an\n  uint64_t @p weight, this function will write the\n  weight for the connection between the device @p dv_ind_src\n  and @p dv_ind_dst to the memory pointed to by @p weight.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] weight A pointer to an uint64_t to which the\n  weight for the connection should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_topo_get_link_weight(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        weight: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retreive minimal and maximal io link bandwidth between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst,  pointer to an\n  uint64_t @p min_bandwidth, and a pointer to uint64_t @p max_bandiwidth,\n  this function will write theoretical minimal and maximal bandwidth limits.\n  API works if src and dst are connected via xgmi and have 1 hop distance.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] min_bandwidth A pointer to an uint64_t to which the\n  minimal bandwidth for the connection should be written.\n\n  @param[inout] max_bandwidth A pointer to an uint64_t to which the\n  maximal bandwidth for the connection should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid"]
    pub fn rsmi_minmax_bandwidth_get(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        min_bandwidth: *mut u64,
        max_bandwidth: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieve the hops and the connection type between GPU to GPU/CPU\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst, and a pointer to an\n  uint64_t @p hops and a pointer to an RSMI_IO_LINK_TYPE @p type,\n  this function will write the number of hops and the connection type\n  between the device @p dv_ind_src and @p dv_ind_dst to the memory\n  pointed to by @p hops and @p type.\n\n  To query the link type between GPU and CPU, given a source GPU index\n  @p dev_ind_srcc and a destination device index @p dv_ind_dst\n  CPU_NODE_INDEX(0xFFFFFFFF), a pointer to an\n  uint64_t @p hops and a pointer to an RSMI_IO_LINK_TYPE @p type,\n  this function will write the number of hops and the connection type\n  between the device @p dv_ind_src and CPU to the memory\n  pointed to by @p hops and @p type.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] hops A pointer to an uint64_t to which the\n  hops for the connection should be written.\n\n  @param[inout] type A pointer to an ::RSMI_IO_LINK_TYPE to which the\n  type for the connection should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_topo_get_link_type(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        hops: *mut u64,
        type_: *mut RSMI_IO_LINK_TYPE,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Return P2P availability status between 2 GPUs\n\n  @details Given a source device index @p dv_ind_src and\n  a destination device index @p dv_ind_dst, and a pointer to a\n  bool @p accessible, this function will write the P2P connection status\n  between the device @p dv_ind_src and @p dv_ind_dst to the memory\n  pointed to by @p accessible.\n\n  @param[in] dv_ind_src the source device index\n\n  @param[in] dv_ind_dst the destination device index\n\n  @param[inout] accessible A pointer to a bool to which the status for\n  the P2P connection availablity should be written.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n"]
    pub fn rsmi_is_P2P_accessible(
        dv_ind_src: u32,
        dv_ind_dst: u32,
        accessible: *mut bool,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieves the current compute partitioning for a desired device\n\n  @details\n  Given a device index @p dv_ind and a string @p compute_partition ,\n  and uint32 @p len , this function will attempt to obtain the device's\n  current compute partition setting string. Upon successful retreival,\n  the obtained device's compute partition settings string shall be stored in\n  the passed @p compute_partition char string variable.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] compute_partition a pointer to a char string variable,\n  which the device's current compute partition will be written to.\n\n  @param[in] len the length of the caller provided buffer @p compute_partition\n  , suggested length is 4 or greater.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_UNEXPECTED_DATA data provided to function is not valid\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire compute partition value. In this case,\n  only @p len bytes will be written.\n"]
    pub fn rsmi_dev_compute_partition_get(
        dv_ind: u32,
        compute_partition: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Modifies a selected device's compute partition setting.\n\n  @details Given a device index @p dv_ind, a type of compute partition\n  @p compute_partition, this function will attempt to update the selected\n  device's compute partition setting.\n\n  @param[in] dv_ind a device index\n\n  @param[in] compute_partition using enum ::rsmi_compute_partition_type_t,\n  define what the selected device's compute partition setting should be\n  updated to.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_SETTING_UNAVAILABLE the provided setting is\n  unavailable for current device\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::RSMI_STATUS_BUSY A resource or mutex could not be acquired\n  because it is already being used - device is busy\n"]
    pub fn rsmi_dev_compute_partition_set(
        dv_ind: u32,
        compute_partition: rsmi_compute_partition_type_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Reverts a selected device's compute partition setting back to its\n  boot state.\n\n  @details Given a device index @p dv_ind , this function will attempt to\n  revert its compute partition setting back to its boot state.\n\n  @param[in] dv_ind a device index\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::RSMI_STATUS_BUSY A resource or mutex could not be acquired\n  because it is already being used - device is busy\n"]
    pub fn rsmi_dev_compute_partition_reset(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Retrieves the current memory partition for a desired device\n\n  @details\n  Given a device index @p dv_ind and a string @p memory_partition ,\n  and uint32 @p len , this function will attempt to obtain the device's\n  memory partition string. Upon successful retreival, the obtained device's\n  memory partition string shall be stored in the passed @p memory_partition\n  char string variable.\n\n  @param[in] dv_ind a device index\n\n  @param[inout] memory_partition a pointer to a char string variable,\n  which the device's memory partition will be written to.\n\n  @param[in] len the length of the caller provided buffer @p memory_partition ,\n  suggested length is 5 or greater.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_UNEXPECTED_DATA data provided to function is not valid\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::RSMI_STATUS_INSUFFICIENT_SIZE is returned if @p len bytes is not\n  large enough to hold the entire memory partition value. In this case,\n  only @p len bytes will be written.\n"]
    pub fn rsmi_dev_memory_partition_get(
        dv_ind: u32,
        memory_partition: *mut ::std::os::raw::c_char,
        len: u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Modifies a selected device's current memory partition setting.\n\n  @details Given a device index @p dv_ind and a type of memory partition\n  @p memory_partition, this function will attempt to update the selected\n  device's memory partition setting.\n\n  @param[in] dv_ind a device index\n\n  @param[in] memory_partition using enum ::rsmi_memory_partition_type_t,\n  define what the selected device's current mode setting should be updated to.\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n  @retval ::RSMI_STATUS_INVALID_ARGS the provided arguments are not valid\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::RSMI_STATUS_AMDGPU_RESTART_ERR could not successfully restart\n  the amdgpu driver\n  @retval ::RSMI_STATUS_BUSY A resource or mutex could not be acquired\n  because it is already being used - device is busy\n"]
    pub fn rsmi_dev_memory_partition_set(
        dv_ind: u32,
        memory_partition: rsmi_memory_partition_type_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Reverts a selected device's memory partition setting back to its\n  boot state.\n\n  @details Given a device index @p dv_ind , this function will attempt to\n  revert its current memory partition setting back to its boot state.\n\n  @param[in] dv_ind a device index\n\n  @retval ::RSMI_STATUS_SUCCESS call was successful\n  @retval ::RSMI_STATUS_PERMISSION function requires root access\n  @retval ::RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not\n  support this function\n  @retval ::RSMI_STATUS_AMDGPU_RESTART_ERR could not successfully restart\n  the amdgpu driver\n  @retval ::RSMI_STATUS_BUSY A resource or mutex could not be acquired\n  because it is already being used - device is busy\n"]
    pub fn rsmi_dev_memory_partition_reset(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Get a function name iterator of supported RSMI functions for a device\n\n @details Given a device index @p dv_ind, this function will write a function\n iterator handle to the caller-provided memory pointed to by @p handle. This\n handle can be used to iterate through all the supported functions.\n\n Note that although this function takes in @p dv_ind as an argument,\n ::rsmi_dev_supported_func_iterator_open itself will not be among the\n functions listed as supported. This is because\n ::rsmi_dev_supported_func_iterator_open does not depend on hardware or\n driver support and should always be supported.\n\n @param[in] dv_ind a device index of device for which support information is\n requested\n\n @param[inout] handle A pointer to caller-provided memory to which the\n function iterator will be written.\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_supported_func_iterator_open(
        dv_ind: u32,
        handle: *mut rsmi_func_id_iter_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Get a variant iterator for a given handle\n\n @details Given a ::rsmi_func_id_iter_handle_t @p obj_h, this function will\n write a function iterator handle to the caller-provided memory pointed to\n by @p var_iter. This handle can be used to iterate through all the supported\n variants of the provided handle. @p obj_h may be a handle to a function\n object, as provided by a call to ::rsmi_dev_supported_func_iterator_open, or\n it may be a variant itself (from a call to\n ::rsmi_dev_supported_variant_iterator_open), it which case @p var_iter will\n be an iterator of the sub-variants of @p obj_h (e.g., monitors).\n\n This call allocates a small amount of memory to @p var_iter. To free this memory\n ::rsmi_dev_supported_func_iterator_close should be called on the returned\n iterator handle @p var_iter when it is no longer needed.\n\n @param[in] obj_h an iterator handle for which the variants are being requested\n\n @param[inout] var_iter A pointer to caller-provided memory to which the\n sub-variant iterator will be written.\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_supported_variant_iterator_open(
        obj_h: rsmi_func_id_iter_handle_t,
        var_iter: *mut rsmi_func_id_iter_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Advance a function identifer iterator\n\n @details Given a function id iterator handle (::rsmi_func_id_iter_handle_t)\n @p handle, this function will increment the iterator to point to the next\n identifier. After a successful call to this function, obtaining the value\n of the iterator @p handle will provide the value of the next item in the\n list of functions/variants.\n\n If there are no more items in the list, ::RSMI_STATUS_NO_DATA is returned.\n\n @param[in] handle A pointer to an iterator handle to be incremented\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n @retval ::RSMI_STATUS_NO_DATA is returned when list of identifiers has been\n exhausted\n"]
    pub fn rsmi_func_iter_next(handle: rsmi_func_id_iter_handle_t) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Close a variant iterator handle\n\n @details Given a pointer to an ::rsmi_func_id_iter_handle_t @p handle, this\n function will free the resources being used by the handle\n\n @param[in] handle A pointer to an iterator handle to be closed\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_supported_func_iterator_close(
        handle: *mut rsmi_func_id_iter_handle_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Get the value associated with a function/variant iterator\n\n @details Given an ::rsmi_func_id_iter_handle_t @p handle, this function\n will write the identifier of the function/variant to the user provided\n memory pointed to by @p value.\n\n @p value may point to a function name, a variant id, or a monitor/sensor\n index, depending on what kind of iterator @p handle is\n\n @param[in] handle An iterator for which the value is being requested\n\n @param[inout] value A pointer to an ::rsmi_func_id_value_t provided by the\n caller to which this function will write the value assocaited with @p handle\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_func_iter_value_get(
        handle: rsmi_func_id_iter_handle_t,
        value: *mut rsmi_func_id_value_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Prepare to collect event notifications for a GPU\n\n @details This function prepares to collect events for the GPU with device\n ID @p dv_ind, by initializing any required system parameters. This call\n may open files which will remain open until ::rsmi_event_notification_stop()\n is called.\n\n @param dv_ind a device index corresponding to the device on which to\n listen for events\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call."]
    pub fn rsmi_event_notification_init(dv_ind: u32) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Specify which events to collect for a device\n\n @details Given a device index @p dv_ind and a @p mask consisting of\n elements of ::rsmi_evt_notification_type_t OR'd together, this function\n will listen for the events specified in @p mask on the device\n corresponding to @p dv_ind.\n\n @param dv_ind a device index corresponding to the device on which to\n listen for events\n\n @param mask Bitmask generated by OR'ing 1 or more elements of\n ::rsmi_evt_notification_type_t indicating which event types to listen for,\n where the rsmi_evt_notification_type_t value indicates the bit field, with\n bit position starting from 1.\n For example, if the mask field is 0x0000000000000003, which means first bit,\n bit 1 (bit position start from 1) and bit 2 are set, which indicate interest\n in receiving RSMI_EVT_NOTIF_VMFAULT (which has a value of 1) and\n RSMI_EVT_NOTIF_THERMAL_THROTTLE event (which has a value of 2).\n\n @retval ::RSMI_STATUS_INIT_ERROR is returned if\n ::rsmi_event_notification_init() has not been called before a call to this\n function\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call"]
    pub fn rsmi_event_notification_mask_set(dv_ind: u32, mask: u64) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Collect event notifications, waiting a specified amount of time\n\n @details Given a time period @p timeout_ms in milliseconds and a caller-\n provided buffer of ::rsmi_evt_notification_data_t's @p data with a length\n (in ::rsmi_evt_notification_data_t's, also specified by the caller) in the\n memory location pointed to by @p num_elem, this function will collect\n ::rsmi_evt_notification_type_t events for up to @p timeout_ms milliseconds,\n and write up to *@p num_elem event items to @p data. Upon return @p num_elem\n is updated with the number of events that were actually written. If events\n are already present when this function is called, it will write the events\n to the buffer then poll for new events if there is still caller-provided\n buffer available to write any new events that would be found.\n\n This function requires prior calls to ::rsmi_event_notification_init() and\n ::rsmi_event_notification_mask_set(). This function polls for the\n occurrance of the events on the respective devices that were previously\n specified by ::rsmi_event_notification_mask_set().\n\n @param[in] timeout_ms number of milliseconds to wait for an event\n to occur\n\n @param[inout] num_elem pointer to uint32_t, provided by the caller. On\n input, this value tells how many ::rsmi_evt_notification_data_t elements\n are being provided by the caller with @p data. On output, the location\n pointed to by @p num_elem will contain the number of items written to\n the provided buffer.\n\n @param[out] data pointer to a caller-provided memory buffer of size\n @p num_elem ::rsmi_evt_notification_data_t to which this function may safely\n write. If there are events found, up to @p num_elem event items will be\n written to @p data.\n\n @retval ::RSMI_STATUS_SUCCESS The function ran successfully. The events\n that were found are written to @p data and @p num_elems is updated\n with the number of elements that were written.\n\n @retval ::RSMI_STATUS_NO_DATA No events were found to collect.\n"]
    pub fn rsmi_event_notification_get(
        timeout_ms: ::std::os::raw::c_int,
        num_elem: *mut u32,
        data: *mut rsmi_evt_notification_data_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = " @brief Close any file handles and free any resources used by event\n notification for a GPU\n\n @details Any resources used by event notification for the GPU with\n device index @p dv_ind will be free with this\n function. This includes freeing any memory and closing file handles. This\n should be called for every call to ::rsmi_event_notification_init()\n\n @param[in] dv_ind The device index of the GPU for which event\n notification resources will be free\n\n @retval ::RSMI_STATUS_INVALID_ARGS resources for the given device have\n either already been freed, or were never allocated by\n ::rsmi_event_notification_init()\n\n @retval ::RSMI_STATUS_SUCCESS is returned upon successful call"]
    pub fn rsmi_event_notification_stop(dv_ind: u32) -> rsmi_status_t;
}
#[doc = " Metric multi-valued counter types"]
pub type GPUMetricTempHbm_t = [u16; 4usize];
pub type GPUMetricVcnActivity_t = [u16; 4usize];
pub type GPUMetricJpegActivity_t = [u16; 32usize];
pub type GPUMetricXgmiReadDataAcc_t = [u64; 8usize];
pub type GPUMetricXgmiWriteDataAcc_t = [u64; 8usize];
pub type GPUMetricCurrGfxClk_t = [u16; 8usize];
pub type GPUMetricCurrSocClk_t = [u16; 4usize];
pub type GPUMetricCurrVClk0_t = [u16; 4usize];
pub type GPUMetricCurrDClk0_t = [u16; 4usize];
extern "C" {
    #[doc = "  @brief Get the 'temp_hotspot' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_hotspot' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] hotspot_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_hotspot_get(dv_ind: u32, hotspot_value: *mut u16)
        -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'temp_mem' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_mem' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] mem_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_mem_get(dv_ind: u32, mem_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'temp_vrsoc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_vrsoc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] vrsoc_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_vrsoc_get(dv_ind: u32, vrsoc_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_socket_power' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'socket_power' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] socket_power_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_socket_power_get(
        dv_ind: u32,
        socket_power_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_gfx_activity' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'gfx_activity' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] gfx_activity_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_gfx_activity_get(
        dv_ind: u32,
        gfx_activity_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_umc_activity' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'umc_activity' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] umc_activity_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_umc_activity_get(
        dv_ind: u32,
        umc_activity_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'energy_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'energy_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] energy_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_energy_acc_get(
        dv_ind: u32,
        energy_acc_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'system_clock_counter' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'system_clock_counter' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] system_clock_counter_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_system_clock_counter_get(
        dv_ind: u32,
        system_clock_counter_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'firmware_timestamp' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'firmware_timestamp' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] firmware_timestamp_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_firmware_timestamp_get(
        dv_ind: u32,
        firmware_timestamp_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'throttle_status' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t in which\n  the 'throttle_status' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] throttle_status_value a pointer to uint32_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_throttle_status_get(
        dv_ind: u32,
        throttle_status_value: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_link_width' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'pcie_link_width' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_link_width_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_link_width_get(
        dv_ind: u32,
        pcie_link_width_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_link_speed' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'pcie_link_speed' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_link_speed_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_link_speed_get(
        dv_ind: u32,
        pcie_link_speed_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'xgmi_link_width' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'xgmi_link_width' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] xgmi_link_width_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_xgmi_link_width_get(
        dv_ind: u32,
        xgmi_link_width_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'xgmi_link_speed' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'xgmi_link_speed' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] xgmi_link_speed_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_xgmi_link_speed_get(
        dv_ind: u32,
        xgmi_link_speed_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'gfxclk_lock_status' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t in which\n  the 'gfxclk_lock_status' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] gfxclk_lock_status_value a pointer to uint32_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_gfxclk_lock_status_get(
        dv_ind: u32,
        gfxclk_lock_status_value: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'gfx_activity_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t in which\n  the 'gfx_activity_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] gfx_activity_acc_value a pointer to uint32_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_gfx_activity_acc_get(
        dv_ind: u32,
        gfx_activity_acc_value: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'mem_activity_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t in which\n  the 'mem_activity_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] mem_activity_acc_value a pointer to uint32_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_mem_activity_acc_get(
        dv_ind: u32,
        mem_activity_acc_value: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_bandwidth_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'pcie_bandwidth_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_bandwidth_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_bandwidth_acc_get(
        dv_ind: u32,
        pcie_bandwidth_acc_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_bandwidth_inst' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'pcie_bandwidth_inst' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_bandwidth_inst_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_bandwidth_inst_get(
        dv_ind: u32,
        pcie_bandwidth_inst_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_l0_recov_count_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'pcie_l0_recov_count_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_count_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_l0_recov_count_acc_get(
        dv_ind: u32,
        pcie_count_acc_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_replay_count_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'pcie_replay_count_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_count_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_replay_count_acc_get(
        dv_ind: u32,
        pcie_count_acc_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_replay_rover_count_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'pcie_replay_rover_count_acc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_count_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_replay_rover_count_acc_get(
        dv_ind: u32,
        pcie_count_acc_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_nak_sent_count_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t in which\n  the 'mem_max_bandwidth_usage' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_nak_sent_count_acc_value a pointer to uint32_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_nak_sent_count_acc_get(
        dv_ind: u32,
        pcie_nak_sent_count_acc_value: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'pcie_nak_rcvd_count_acc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint32_t in which\n  the 'mem_max_bandwidth_usage' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] pcie_nak_rcvd_count_acc_value a pointer to uint32_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_pcie_nak_rcvd_count_acc_get(
        dv_ind: u32,
        pcie_nak_rcvd_count_acc_value: *mut u32,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_uclk' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_uclk' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] uclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_uclk_get(dv_ind: u32, uclk_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'temp_hbm' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_hbm' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] temp_hbm_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding a 4 (RSMI_NUM_HBM_INSTANCES)\n        element array (GPUMetricTempHbm_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_hbm_get(
        dv_ind: u32,
        temp_hbm_value: *mut GPUMetricTempHbm_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'vcn_activity' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'vcn_activity' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] vcn_activity_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding a 4 (RSMI_MAX_NUM_VCNS)\n        element array (GPUMetricVcnActivity_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_vcn_activity_get(
        dv_ind: u32,
        vcn_activity_value: *mut GPUMetricVcnActivity_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'jpeg_activity' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'vcn_activity' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] jpeg_activity_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding a 32 (RSMI_MAX_NUM_JPEG_ENGS)\n        element array (GPUMetricJpegActivity_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_jpeg_activity_get(
        dv_ind: u32,
        jpeg_activity_value: *mut GPUMetricJpegActivity_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'xgmi_read_data' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'xgmi_read_data' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] xgmi_read_data_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding an 8 (RSMI_MAX_NUM_XGMI_LINKS)\n        element array (GPUMetricXgmiReadDataAcc_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_xgmi_read_data_get(
        dv_ind: u32,
        xgmi_read_data_acc_value: *mut GPUMetricXgmiReadDataAcc_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'xgmi_write_data' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'xgmi_write_data' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] xgmi_write_data_acc_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding an 8 (RSMI_MAX_NUM_XGMI_LINKS)\n        element array (GPUMetricXgmiWriteDataAcc_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_xgmi_write_data_get(
        dv_ind: u32,
        xgmi_write_data_acc_value: *mut GPUMetricXgmiWriteDataAcc_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_gfxclk' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'curr_gfxclk' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] current_gfxclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding an 8 (RSMI_MAX_NUM_GFX_CLKS)\n        element array (GPUMetricCurrGfxClk_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_gfxclk_get(
        dv_ind: u32,
        current_gfxclk_value: *mut GPUMetricCurrGfxClk_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_socclk' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_socclk' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] current_socclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS)\n        element array (GPUMetricCurrSocClk_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_socclk_get(
        dv_ind: u32,
        current_socclk_value: *mut GPUMetricCurrSocClk_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_vclk0' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_vclk0' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] current_vclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS)\n        element array (GPUMetricCurrVClk0_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_vclk0_get(
        dv_ind: u32,
        current_vclk_value: *mut GPUMetricCurrVClk0_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_dclk0' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_dclk0' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] current_dclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n      - This is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS)\n        element array (GPUMetricCurrDClk0_t)\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_dclk0_get(
        dv_ind: u32,
        current_dclk_value: *mut GPUMetricCurrDClk0_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'temp_edge' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_edge' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] edge_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_edge_get(dv_ind: u32, edge_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'temp_vrgfx' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_vrgfx' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] vrgfx_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_vrgfx_get(dv_ind: u32, vrgfx_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'temp_vrmem' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'temp_vrmem' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] vrmem_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_temp_vrmem_get(dv_ind: u32, vrmem_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_mm_activity' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_mm_activity' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] mm_activity_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_mm_activity_get(
        dv_ind: u32,
        mm_activity_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_vclk1' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_vclk1' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] current_vclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_vclk1_get(
        dv_ind: u32,
        current_vclk_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_dclk1' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_dclk1' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] current_dclk_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_dclk1_get(
        dv_ind: u32,
        current_dclk_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'indep_throttle_status' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint64_t in which\n  the 'indep_throttle_status' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] throttle_status_value a pointer to uint64_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_indep_throttle_status_get(
        dv_ind: u32,
        throttle_status_value: *mut u64,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_socket_power' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_socket_power' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] socket_power_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_socket_power_get(
        dv_ind: u32,
        socket_power_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'curr_fan_speed' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'curr_fan_speed' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] fan_speed_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_curr_fan_speed_get(
        dv_ind: u32,
        fan_speed_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_gfx_clock_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_gfx_clock_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_gfx_clock_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_soc_clock_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_soc_clock_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_soc_clock_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_uclock_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_uclock_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_uclock_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_vclock0_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_vclock0_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_vclock0_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_dclock0_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_dclock0_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_dclock0_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_vclock1_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_vclock1_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_vclock1_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'avg_dclock1_frequency' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'avg_dclock1_frequency' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] clock_frequency_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_avg_dclock1_frequency_get(
        dv_ind: u32,
        clock_frequency_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'volt_soc' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'volt_soc' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] voltage_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_volt_soc_get(dv_ind: u32, voltage_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'volt_gfx' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'volt_gfx' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] voltage_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_volt_gfx_get(dv_ind: u32, voltage_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'volt_mem' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'volt_mem' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] voltage_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_volt_mem_get(dv_ind: u32, voltage_value: *mut u16) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'metrics_header_info' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a metrics_table_header_t in which\n  the 'metrics_header_info' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] header_value a pointer to metrics_table_header_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_header_info_get(
        dv_ind: u32,
        header_value: *mut metrics_table_header_t,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the 'xcd_counter' from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind and a pointer to a uint16_t in which\n  the 'xcd_counter' will stored\n\n  @param[in] dv_ind a device index\n\n  @param[inout] xcd_counter_value a pointer to uint16_t to which the device gpu\n  metric unit will be stored\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n          ::RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit\n            does not exist for the given device\n"]
    pub fn rsmi_dev_metrics_xcd_counter_get(
        dv_ind: u32,
        xcd_counter_value: *mut u16,
    ) -> rsmi_status_t;
}
extern "C" {
    #[doc = "  @brief Get the log from the GPU metrics associated with the device\n\n  @details Given a device index @p dv_ind it will log all the gpu metric info\n  related to the device. The 'logging' feature must be on.\n\n  @param[in] dv_ind a device index\n\n  @retval ::RSMI_STATUS_SUCCESS is returned upon successful call.\n"]
    pub fn rsmi_dev_metrics_log_get(dv_ind: u32) -> rsmi_status_t;
}
